/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is generated by generate_channels.js, do not edit manually.

import { EventEmitter } from 'events';
import * as types from '../protocol/types';
import { CallMetadata } from '../server/instrumentation';
export * from '../protocol/types';

export interface Channel extends EventEmitter {
}

// ----------- Playwright -----------
export type PlaywrightInitializer = {
  chromium: BrowserTypeChannel,
  firefox: BrowserTypeChannel,
  webkit: BrowserTypeChannel,
  android: AndroidChannel,
  electron: ElectronChannel,
  deviceDescriptors: {
    name: string,
    descriptor: {
      userAgent: string,
      viewport: {
        width: number,
        height: number,
      },
      deviceScaleFactor: number,
      isMobile: boolean,
      hasTouch: boolean,
      defaultBrowserType: 'chromium' | 'firefox' | 'webkit',
    },
  }[],
  selectors: SelectorsChannel,
};
export interface PlaywrightChannel extends Channel {
}

// ----------- RemoteBrowser -----------
export type RemoteBrowserInitializer = {
  browser: BrowserChannel,
  selectors: SelectorsChannel,
};
export interface RemoteBrowserChannel extends Channel {
}
export type RemoteBrowserVideoEvent = {
  context: BrowserContextChannel,
  stream: StreamChannel,
  relativePath: string,
};

// ----------- Selectors -----------
export type SelectorsInitializer = {};
export interface SelectorsChannel extends Channel {
  register(params: SelectorsRegisterParams, metadata?: CallMetadata): Promise<SelectorsRegisterResult>;
}
export type SelectorsRegisterParams = {
  name: string,
  source: string,
  contentScript?: boolean,
};
export type SelectorsRegisterOptions = {
  contentScript?: boolean,
};
export type SelectorsRegisterResult = void;

// ----------- BrowserType -----------
export type BrowserTypeInitializer = {
  executablePath: string,
  name: string,
};
export interface BrowserTypeChannel extends Channel {
  launch(params: BrowserTypeLaunchParams, metadata?: CallMetadata): Promise<BrowserTypeLaunchResult>;
  launchPersistentContext(params: BrowserTypeLaunchPersistentContextParams, metadata?: CallMetadata): Promise<BrowserTypeLaunchPersistentContextResult>;
  connectOverCDP(params: BrowserTypeConnectOverCDPParams, metadata?: CallMetadata): Promise<BrowserTypeConnectOverCDPResult>;
}
export type BrowserTypeLaunchParams = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchResult = {
  browser: BrowserChannel,
};
export type BrowserTypeLaunchPersistentContextParams = {
  userDataDir: string,
  sdkLanguage: string,
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextResult = {
  context: BrowserContextChannel,
};
export type BrowserTypeConnectOverCDPParams = {
  sdkLanguage: string,
  wsEndpoint: string,
  slowMo?: number,
  timeout?: number,
};
export type BrowserTypeConnectOverCDPOptions = {
  slowMo?: number,
  timeout?: number,
};
export type BrowserTypeConnectOverCDPResult = {
  browser: BrowserChannel,
  defaultContext?: BrowserContextChannel,
};

// ----------- Browser -----------
export type BrowserInitializer = {
  version: string,
  name: string,
};
export interface BrowserChannel extends Channel {
  close(params?: BrowserCloseParams, metadata?: CallMetadata): Promise<BrowserCloseResult>;
  newContext(params: BrowserNewContextParams, metadata?: CallMetadata): Promise<BrowserNewContextResult>;
  crNewBrowserCDPSession(params?: BrowserCrNewBrowserCDPSessionParams, metadata?: CallMetadata): Promise<BrowserCrNewBrowserCDPSessionResult>;
  crStartTracing(params: BrowserCrStartTracingParams, metadata?: CallMetadata): Promise<BrowserCrStartTracingResult>;
  crStopTracing(params?: BrowserCrStopTracingParams, metadata?: CallMetadata): Promise<BrowserCrStopTracingResult>;
}
export type BrowserCloseEvent = {};
export type BrowserCloseParams = {};
export type BrowserCloseOptions = {};
export type BrowserCloseResult = void;
export type BrowserNewContextParams = {
  sdkLanguage: string,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: types.SetNetworkCookie[],
    origins?: types.OriginStorage[],
  },
};
export type BrowserNewContextOptions = {
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: types.SetNetworkCookie[],
    origins?: types.OriginStorage[],
  },
};
export type BrowserNewContextResult = {
  context: BrowserContextChannel,
};
export type BrowserCrNewBrowserCDPSessionParams = {};
export type BrowserCrNewBrowserCDPSessionOptions = {};
export type BrowserCrNewBrowserCDPSessionResult = {
  session: CDPSessionChannel,
};
export type BrowserCrStartTracingParams = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingOptions = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingResult = void;
export type BrowserCrStopTracingParams = {};
export type BrowserCrStopTracingOptions = {};
export type BrowserCrStopTracingResult = {
  binary: types.Binary,
};

// ----------- BrowserContext -----------
export type BrowserContextInitializer = {
  isChromium: boolean,
};
export interface BrowserContextChannel extends Channel {
  addCookies(params: BrowserContextAddCookiesParams, metadata?: CallMetadata): Promise<BrowserContextAddCookiesResult>;
  addInitScript(params: BrowserContextAddInitScriptParams, metadata?: CallMetadata): Promise<BrowserContextAddInitScriptResult>;
  clearCookies(params?: BrowserContextClearCookiesParams, metadata?: CallMetadata): Promise<BrowserContextClearCookiesResult>;
  clearPermissions(params?: BrowserContextClearPermissionsParams, metadata?: CallMetadata): Promise<BrowserContextClearPermissionsResult>;
  close(params?: BrowserContextCloseParams, metadata?: CallMetadata): Promise<BrowserContextCloseResult>;
  cookies(params: BrowserContextCookiesParams, metadata?: CallMetadata): Promise<BrowserContextCookiesResult>;
  exposeBinding(params: BrowserContextExposeBindingParams, metadata?: CallMetadata): Promise<BrowserContextExposeBindingResult>;
  grantPermissions(params: BrowserContextGrantPermissionsParams, metadata?: CallMetadata): Promise<BrowserContextGrantPermissionsResult>;
  newPage(params?: BrowserContextNewPageParams, metadata?: CallMetadata): Promise<BrowserContextNewPageResult>;
  setDefaultNavigationTimeoutNoReply(params: BrowserContextSetDefaultNavigationTimeoutNoReplyParams, metadata?: CallMetadata): Promise<BrowserContextSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: BrowserContextSetDefaultTimeoutNoReplyParams, metadata?: CallMetadata): Promise<BrowserContextSetDefaultTimeoutNoReplyResult>;
  setExtraHTTPHeaders(params: BrowserContextSetExtraHTTPHeadersParams, metadata?: CallMetadata): Promise<BrowserContextSetExtraHTTPHeadersResult>;
  setGeolocation(params: BrowserContextSetGeolocationParams, metadata?: CallMetadata): Promise<BrowserContextSetGeolocationResult>;
  setHTTPCredentials(params: BrowserContextSetHTTPCredentialsParams, metadata?: CallMetadata): Promise<BrowserContextSetHTTPCredentialsResult>;
  setNetworkInterceptionEnabled(params: BrowserContextSetNetworkInterceptionEnabledParams, metadata?: CallMetadata): Promise<BrowserContextSetNetworkInterceptionEnabledResult>;
  setOffline(params: BrowserContextSetOfflineParams, metadata?: CallMetadata): Promise<BrowserContextSetOfflineResult>;
  storageState(params?: BrowserContextStorageStateParams, metadata?: CallMetadata): Promise<BrowserContextStorageStateResult>;
  pause(params?: BrowserContextPauseParams, metadata?: CallMetadata): Promise<BrowserContextPauseResult>;
  recorderSupplementEnable(params: BrowserContextRecorderSupplementEnableParams, metadata?: CallMetadata): Promise<BrowserContextRecorderSupplementEnableResult>;
  crNewCDPSession(params: BrowserContextCrNewCDPSessionParams, metadata?: CallMetadata): Promise<BrowserContextCrNewCDPSessionResult>;
}
export type BrowserContextBindingCallEvent = {
  binding: BindingCallChannel,
};
export type BrowserContextCloseEvent = {};
export type BrowserContextPageEvent = {
  page: PageChannel,
};
export type BrowserContextRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type BrowserContextCrBackgroundPageEvent = {
  page: PageChannel,
};
export type BrowserContextCrServiceWorkerEvent = {
  worker: WorkerChannel,
};
export type BrowserContextAddCookiesParams = {
  cookies: types.SetNetworkCookie[],
};
export type BrowserContextAddCookiesOptions = {

};
export type BrowserContextAddCookiesResult = void;
export type BrowserContextAddInitScriptParams = {
  source: string,
};
export type BrowserContextAddInitScriptOptions = {

};
export type BrowserContextAddInitScriptResult = void;
export type BrowserContextClearCookiesParams = {};
export type BrowserContextClearCookiesOptions = {};
export type BrowserContextClearCookiesResult = void;
export type BrowserContextClearPermissionsParams = {};
export type BrowserContextClearPermissionsOptions = {};
export type BrowserContextClearPermissionsResult = void;
export type BrowserContextCloseParams = {};
export type BrowserContextCloseOptions = {};
export type BrowserContextCloseResult = void;
export type BrowserContextCookiesParams = {
  urls: string[],
};
export type BrowserContextCookiesOptions = {

};
export type BrowserContextCookiesResult = {
  cookies: types.NetworkCookie[],
};
export type BrowserContextExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingOptions = {
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingResult = void;
export type BrowserContextGrantPermissionsParams = {
  permissions: string[],
  origin?: string,
};
export type BrowserContextGrantPermissionsOptions = {
  origin?: string,
};
export type BrowserContextGrantPermissionsResult = void;
export type BrowserContextNewPageParams = {};
export type BrowserContextNewPageOptions = {};
export type BrowserContextNewPageResult = {
  page: PageChannel,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyResult = void;
export type BrowserContextSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultTimeoutNoReplyResult = void;
export type BrowserContextSetExtraHTTPHeadersParams = {
  headers: types.NameValue[],
};
export type BrowserContextSetExtraHTTPHeadersOptions = {

};
export type BrowserContextSetExtraHTTPHeadersResult = void;
export type BrowserContextSetGeolocationParams = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationOptions = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationResult = void;
export type BrowserContextSetHTTPCredentialsParams = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsOptions = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsResult = void;
export type BrowserContextSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type BrowserContextSetNetworkInterceptionEnabledOptions = {

};
export type BrowserContextSetNetworkInterceptionEnabledResult = void;
export type BrowserContextSetOfflineParams = {
  offline: boolean,
};
export type BrowserContextSetOfflineOptions = {

};
export type BrowserContextSetOfflineResult = void;
export type BrowserContextStorageStateParams = {};
export type BrowserContextStorageStateOptions = {};
export type BrowserContextStorageStateResult = {
  cookies: types.NetworkCookie[],
  origins: types.OriginStorage[],
};
export type BrowserContextPauseParams = {};
export type BrowserContextPauseOptions = {};
export type BrowserContextPauseResult = void;
export type BrowserContextRecorderSupplementEnableParams = {
  recorderParameters: types.RecorderParameters,
};
export type BrowserContextRecorderSupplementEnableOptions = {

};
export type BrowserContextRecorderSupplementEnableResult = void;
export type BrowserContextCrNewCDPSessionParams = {
  page: PageChannel,
};
export type BrowserContextCrNewCDPSessionOptions = {

};
export type BrowserContextCrNewCDPSessionResult = {
  session: CDPSessionChannel,
};

// ----------- Page -----------
export type PageInitializer = {
  mainFrame: FrameChannel,
  viewportSize?: {
    width: number,
    height: number,
  },
  isClosed: boolean,
  videoRelativePath?: string,
};
export interface PageChannel extends Channel {
  setDefaultNavigationTimeoutNoReply(params: PageSetDefaultNavigationTimeoutNoReplyParams, metadata?: CallMetadata): Promise<PageSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: PageSetDefaultTimeoutNoReplyParams, metadata?: CallMetadata): Promise<PageSetDefaultTimeoutNoReplyResult>;
  setFileChooserInterceptedNoReply(params: PageSetFileChooserInterceptedNoReplyParams, metadata?: CallMetadata): Promise<PageSetFileChooserInterceptedNoReplyResult>;
  addInitScript(params: PageAddInitScriptParams, metadata?: CallMetadata): Promise<PageAddInitScriptResult>;
  close(params: PageCloseParams, metadata?: CallMetadata): Promise<PageCloseResult>;
  emulateMedia(params: PageEmulateMediaParams, metadata?: CallMetadata): Promise<PageEmulateMediaResult>;
  exposeBinding(params: PageExposeBindingParams, metadata?: CallMetadata): Promise<PageExposeBindingResult>;
  goBack(params: PageGoBackParams, metadata?: CallMetadata): Promise<PageGoBackResult>;
  goForward(params: PageGoForwardParams, metadata?: CallMetadata): Promise<PageGoForwardResult>;
  opener(params?: PageOpenerParams, metadata?: CallMetadata): Promise<PageOpenerResult>;
  reload(params: PageReloadParams, metadata?: CallMetadata): Promise<PageReloadResult>;
  screenshot(params: PageScreenshotParams, metadata?: CallMetadata): Promise<PageScreenshotResult>;
  setExtraHTTPHeaders(params: PageSetExtraHTTPHeadersParams, metadata?: CallMetadata): Promise<PageSetExtraHTTPHeadersResult>;
  setNetworkInterceptionEnabled(params: PageSetNetworkInterceptionEnabledParams, metadata?: CallMetadata): Promise<PageSetNetworkInterceptionEnabledResult>;
  setViewportSize(params: PageSetViewportSizeParams, metadata?: CallMetadata): Promise<PageSetViewportSizeResult>;
  keyboardDown(params: PageKeyboardDownParams, metadata?: CallMetadata): Promise<PageKeyboardDownResult>;
  keyboardUp(params: PageKeyboardUpParams, metadata?: CallMetadata): Promise<PageKeyboardUpResult>;
  keyboardInsertText(params: PageKeyboardInsertTextParams, metadata?: CallMetadata): Promise<PageKeyboardInsertTextResult>;
  keyboardType(params: PageKeyboardTypeParams, metadata?: CallMetadata): Promise<PageKeyboardTypeResult>;
  keyboardPress(params: PageKeyboardPressParams, metadata?: CallMetadata): Promise<PageKeyboardPressResult>;
  mouseMove(params: PageMouseMoveParams, metadata?: CallMetadata): Promise<PageMouseMoveResult>;
  mouseDown(params: PageMouseDownParams, metadata?: CallMetadata): Promise<PageMouseDownResult>;
  mouseUp(params: PageMouseUpParams, metadata?: CallMetadata): Promise<PageMouseUpResult>;
  mouseClick(params: PageMouseClickParams, metadata?: CallMetadata): Promise<PageMouseClickResult>;
  touchscreenTap(params: PageTouchscreenTapParams, metadata?: CallMetadata): Promise<PageTouchscreenTapResult>;
  accessibilitySnapshot(params: PageAccessibilitySnapshotParams, metadata?: CallMetadata): Promise<PageAccessibilitySnapshotResult>;
  pdf(params: PagePdfParams, metadata?: CallMetadata): Promise<PagePdfResult>;
  crStartJSCoverage(params: PageCrStartJSCoverageParams, metadata?: CallMetadata): Promise<PageCrStartJSCoverageResult>;
  crStopJSCoverage(params?: PageCrStopJSCoverageParams, metadata?: CallMetadata): Promise<PageCrStopJSCoverageResult>;
  crStartCSSCoverage(params: PageCrStartCSSCoverageParams, metadata?: CallMetadata): Promise<PageCrStartCSSCoverageResult>;
  crStopCSSCoverage(params?: PageCrStopCSSCoverageParams, metadata?: CallMetadata): Promise<PageCrStopCSSCoverageResult>;
  bringToFront(params?: PageBringToFrontParams, metadata?: CallMetadata): Promise<PageBringToFrontResult>;
}
export type PageBindingCallEvent = {
  binding: BindingCallChannel,
};
export type PageCloseEvent = {};
export type PageConsoleEvent = {
  message: ConsoleMessageChannel,
};
export type PageCrashEvent = {};
export type PageDialogEvent = {
  dialog: DialogChannel,
};
export type PageDownloadEvent = {
  download: DownloadChannel,
};
export type PageDomcontentloadedEvent = {};
export type PageFileChooserEvent = {
  element: ElementHandleChannel,
  isMultiple: boolean,
};
export type PageFrameAttachedEvent = {
  frame: FrameChannel,
};
export type PageFrameDetachedEvent = {
  frame: FrameChannel,
};
export type PageLoadEvent = {};
export type PagePageErrorEvent = {
  error: types.SerializedError,
};
export type PagePopupEvent = {
  page: PageChannel,
};
export type PageRequestEvent = {
  request: RequestChannel,
};
export type PageRequestFailedEvent = {
  request: RequestChannel,
  failureText?: string,
  responseEndTiming: number,
};
export type PageRequestFinishedEvent = {
  request: RequestChannel,
  responseEndTiming: number,
};
export type PageResponseEvent = {
  response: ResponseChannel,
};
export type PageRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type PageVideoEvent = {
  relativePath: string,
};
export type PageWebSocketEvent = {
  webSocket: WebSocketChannel,
};
export type PageWorkerEvent = {
  worker: WorkerChannel,
};
export type PageSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type PageSetDefaultNavigationTimeoutNoReplyResult = void;
export type PageSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultTimeoutNoReplyOptions = {

};
export type PageSetDefaultTimeoutNoReplyResult = void;
export type PageSetFileChooserInterceptedNoReplyParams = {
  intercepted: boolean,
};
export type PageSetFileChooserInterceptedNoReplyOptions = {

};
export type PageSetFileChooserInterceptedNoReplyResult = void;
export type PageAddInitScriptParams = {
  source: string,
};
export type PageAddInitScriptOptions = {

};
export type PageAddInitScriptResult = void;
export type PageCloseParams = {
  runBeforeUnload?: boolean,
};
export type PageCloseOptions = {
  runBeforeUnload?: boolean,
};
export type PageCloseResult = void;
export type PageEmulateMediaParams = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaOptions = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaResult = void;
export type PageExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type PageExposeBindingOptions = {
  needsHandle?: boolean,
};
export type PageExposeBindingResult = void;
export type PageGoBackParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackResult = {
  response?: ResponseChannel,
};
export type PageGoForwardParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardResult = {
  response?: ResponseChannel,
};
export type PageOpenerParams = {};
export type PageOpenerOptions = {};
export type PageOpenerResult = {
  page?: PageChannel,
};
export type PageReloadParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadResult = {
  response?: ResponseChannel,
};
export type PageScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: types.Rect,
};
export type PageScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: types.Rect,
};
export type PageScreenshotResult = {
  binary: types.Binary,
};
export type PageSetExtraHTTPHeadersParams = {
  headers: types.NameValue[],
};
export type PageSetExtraHTTPHeadersOptions = {

};
export type PageSetExtraHTTPHeadersResult = void;
export type PageSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type PageSetNetworkInterceptionEnabledOptions = {

};
export type PageSetNetworkInterceptionEnabledResult = void;
export type PageSetViewportSizeParams = {
  viewportSize: {
    width: number,
    height: number,
  },
};
export type PageSetViewportSizeOptions = {

};
export type PageSetViewportSizeResult = void;
export type PageKeyboardDownParams = {
  key: string,
};
export type PageKeyboardDownOptions = {

};
export type PageKeyboardDownResult = void;
export type PageKeyboardUpParams = {
  key: string,
};
export type PageKeyboardUpOptions = {

};
export type PageKeyboardUpResult = void;
export type PageKeyboardInsertTextParams = {
  text: string,
};
export type PageKeyboardInsertTextOptions = {

};
export type PageKeyboardInsertTextResult = void;
export type PageKeyboardTypeParams = {
  text: string,
  delay?: number,
};
export type PageKeyboardTypeOptions = {
  delay?: number,
};
export type PageKeyboardTypeResult = void;
export type PageKeyboardPressParams = {
  key: string,
  delay?: number,
};
export type PageKeyboardPressOptions = {
  delay?: number,
};
export type PageKeyboardPressResult = void;
export type PageMouseMoveParams = {
  x: number,
  y: number,
  steps?: number,
};
export type PageMouseMoveOptions = {
  steps?: number,
};
export type PageMouseMoveResult = void;
export type PageMouseDownParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownResult = void;
export type PageMouseUpParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpResult = void;
export type PageMouseClickParams = {
  x: number,
  y: number,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickOptions = {
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickResult = void;
export type PageTouchscreenTapParams = {
  x: number,
  y: number,
};
export type PageTouchscreenTapOptions = {

};
export type PageTouchscreenTapResult = void;
export type PageAccessibilitySnapshotParams = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotOptions = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotResult = {
  rootAXNode?: types.AXNode,
};
export type PagePdfParams = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfOptions = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfResult = {
  pdf: types.Binary,
};
export type PageCrStartJSCoverageParams = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageOptions = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageResult = void;
export type PageCrStopJSCoverageParams = {};
export type PageCrStopJSCoverageOptions = {};
export type PageCrStopJSCoverageResult = {
  entries: {
    url: string,
    scriptId: string,
    source?: string,
    functions: {
      functionName: string,
      isBlockCoverage: boolean,
      ranges: {
        startOffset: number,
        endOffset: number,
        count: number,
      }[],
    }[],
  }[],
};
export type PageCrStartCSSCoverageParams = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageOptions = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageResult = void;
export type PageCrStopCSSCoverageParams = {};
export type PageCrStopCSSCoverageOptions = {};
export type PageCrStopCSSCoverageResult = {
  entries: {
    url: string,
    text?: string,
    ranges: {
      start: number,
      end: number,
    }[],
  }[],
};
export type PageBringToFrontParams = {};
export type PageBringToFrontOptions = {};
export type PageBringToFrontResult = void;

// ----------- Frame -----------
export type FrameInitializer = {
  url: string,
  name: string,
  parentFrame?: FrameChannel,
  loadStates: ('load' | 'domcontentloaded' | 'networkidle')[],
};
export interface FrameChannel extends Channel {
  evalOnSelector(params: FrameEvalOnSelectorParams, metadata?: CallMetadata): Promise<FrameEvalOnSelectorResult>;
  evalOnSelectorAll(params: FrameEvalOnSelectorAllParams, metadata?: CallMetadata): Promise<FrameEvalOnSelectorAllResult>;
  addScriptTag(params: FrameAddScriptTagParams, metadata?: CallMetadata): Promise<FrameAddScriptTagResult>;
  addStyleTag(params: FrameAddStyleTagParams, metadata?: CallMetadata): Promise<FrameAddStyleTagResult>;
  check(params: FrameCheckParams, metadata?: CallMetadata): Promise<FrameCheckResult>;
  click(params: FrameClickParams, metadata?: CallMetadata): Promise<FrameClickResult>;
  content(params?: FrameContentParams, metadata?: CallMetadata): Promise<FrameContentResult>;
  dblclick(params: FrameDblclickParams, metadata?: CallMetadata): Promise<FrameDblclickResult>;
  dispatchEvent(params: FrameDispatchEventParams, metadata?: CallMetadata): Promise<FrameDispatchEventResult>;
  evaluateExpression(params: FrameEvaluateExpressionParams, metadata?: CallMetadata): Promise<FrameEvaluateExpressionResult>;
  evaluateExpressionHandle(params: FrameEvaluateExpressionHandleParams, metadata?: CallMetadata): Promise<FrameEvaluateExpressionHandleResult>;
  fill(params: FrameFillParams, metadata?: CallMetadata): Promise<FrameFillResult>;
  focus(params: FrameFocusParams, metadata?: CallMetadata): Promise<FrameFocusResult>;
  frameElement(params?: FrameFrameElementParams, metadata?: CallMetadata): Promise<FrameFrameElementResult>;
  getAttribute(params: FrameGetAttributeParams, metadata?: CallMetadata): Promise<FrameGetAttributeResult>;
  goto(params: FrameGotoParams, metadata?: CallMetadata): Promise<FrameGotoResult>;
  hover(params: FrameHoverParams, metadata?: CallMetadata): Promise<FrameHoverResult>;
  innerHTML(params: FrameInnerHTMLParams, metadata?: CallMetadata): Promise<FrameInnerHTMLResult>;
  innerText(params: FrameInnerTextParams, metadata?: CallMetadata): Promise<FrameInnerTextResult>;
  isChecked(params: FrameIsCheckedParams, metadata?: CallMetadata): Promise<FrameIsCheckedResult>;
  isDisabled(params: FrameIsDisabledParams, metadata?: CallMetadata): Promise<FrameIsDisabledResult>;
  isEnabled(params: FrameIsEnabledParams, metadata?: CallMetadata): Promise<FrameIsEnabledResult>;
  isHidden(params: FrameIsHiddenParams, metadata?: CallMetadata): Promise<FrameIsHiddenResult>;
  isVisible(params: FrameIsVisibleParams, metadata?: CallMetadata): Promise<FrameIsVisibleResult>;
  isEditable(params: FrameIsEditableParams, metadata?: CallMetadata): Promise<FrameIsEditableResult>;
  press(params: FramePressParams, metadata?: CallMetadata): Promise<FramePressResult>;
  querySelector(params: FrameQuerySelectorParams, metadata?: CallMetadata): Promise<FrameQuerySelectorResult>;
  querySelectorAll(params: FrameQuerySelectorAllParams, metadata?: CallMetadata): Promise<FrameQuerySelectorAllResult>;
  selectOption(params: FrameSelectOptionParams, metadata?: CallMetadata): Promise<FrameSelectOptionResult>;
  setContent(params: FrameSetContentParams, metadata?: CallMetadata): Promise<FrameSetContentResult>;
  setInputFiles(params: FrameSetInputFilesParams, metadata?: CallMetadata): Promise<FrameSetInputFilesResult>;
  tap(params: FrameTapParams, metadata?: CallMetadata): Promise<FrameTapResult>;
  textContent(params: FrameTextContentParams, metadata?: CallMetadata): Promise<FrameTextContentResult>;
  title(params?: FrameTitleParams, metadata?: CallMetadata): Promise<FrameTitleResult>;
  type(params: FrameTypeParams, metadata?: CallMetadata): Promise<FrameTypeResult>;
  uncheck(params: FrameUncheckParams, metadata?: CallMetadata): Promise<FrameUncheckResult>;
  waitForFunction(params: FrameWaitForFunctionParams, metadata?: CallMetadata): Promise<FrameWaitForFunctionResult>;
  waitForSelector(params: FrameWaitForSelectorParams, metadata?: CallMetadata): Promise<FrameWaitForSelectorResult>;
}
export type FrameLoadstateEvent = {
  add?: 'load' | 'domcontentloaded' | 'networkidle',
  remove?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameNavigatedEvent = {
  url: string,
  name: string,
  newDocument?: {
    request?: RequestChannel,
  },
  error?: string,
};
export type FrameEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type FrameEvalOnSelectorOptions = {
  isFunction?: boolean,
};
export type FrameEvalOnSelectorResult = {
  value: types.SerializedValue,
};
export type FrameEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type FrameEvalOnSelectorAllOptions = {
  isFunction?: boolean,
};
export type FrameEvalOnSelectorAllResult = {
  value: types.SerializedValue,
};
export type FrameAddScriptTagParams = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagOptions = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagResult = {
  element: ElementHandleChannel,
};
export type FrameAddStyleTagParams = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagOptions = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagResult = {
  element: ElementHandleChannel,
};
export type FrameCheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckResult = void;
export type FrameClickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickResult = void;
export type FrameContentParams = {};
export type FrameContentOptions = {};
export type FrameContentResult = {
  value: string,
};
export type FrameDblclickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickResult = void;
export type FrameDispatchEventParams = {
  selector: string,
  type: string,
  eventInit: types.SerializedArgument,
  timeout?: number,
};
export type FrameDispatchEventOptions = {
  timeout?: number,
};
export type FrameDispatchEventResult = void;
export type FrameEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionOptions = {
  isFunction?: boolean,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type FrameEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type FrameFillParams = {
  selector: string,
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillResult = void;
export type FrameFocusParams = {
  selector: string,
  timeout?: number,
};
export type FrameFocusOptions = {
  timeout?: number,
};
export type FrameFocusResult = void;
export type FrameFrameElementParams = {};
export type FrameFrameElementOptions = {};
export type FrameFrameElementResult = {
  element: ElementHandleChannel,
};
export type FrameGetAttributeParams = {
  selector: string,
  name: string,
  timeout?: number,
};
export type FrameGetAttributeOptions = {
  timeout?: number,
};
export type FrameGetAttributeResult = {
  value?: string,
};
export type FrameGotoParams = {
  url: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoResult = {
  response?: ResponseChannel,
};
export type FrameHoverParams = {
  selector: string,
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameHoverResult = void;
export type FrameInnerHTMLParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerHTMLOptions = {
  timeout?: number,
};
export type FrameInnerHTMLResult = {
  value: string,
};
export type FrameInnerTextParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerTextOptions = {
  timeout?: number,
};
export type FrameInnerTextResult = {
  value: string,
};
export type FrameIsCheckedParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsCheckedOptions = {
  timeout?: number,
};
export type FrameIsCheckedResult = {
  value: boolean,
};
export type FrameIsDisabledParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsDisabledOptions = {
  timeout?: number,
};
export type FrameIsDisabledResult = {
  value: boolean,
};
export type FrameIsEnabledParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsEnabledOptions = {
  timeout?: number,
};
export type FrameIsEnabledResult = {
  value: boolean,
};
export type FrameIsHiddenParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsHiddenOptions = {
  timeout?: number,
};
export type FrameIsHiddenResult = {
  value: boolean,
};
export type FrameIsVisibleParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsVisibleOptions = {
  timeout?: number,
};
export type FrameIsVisibleResult = {
  value: boolean,
};
export type FrameIsEditableParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsEditableOptions = {
  timeout?: number,
};
export type FrameIsEditableResult = {
  value: boolean,
};
export type FramePressParams = {
  selector: string,
  key: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressResult = void;
export type FrameQuerySelectorParams = {
  selector: string,
};
export type FrameQuerySelectorOptions = {

};
export type FrameQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type FrameQuerySelectorAllParams = {
  selector: string,
};
export type FrameQuerySelectorAllOptions = {

};
export type FrameQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type FrameSelectOptionParams = {
  selector: string,
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionResult = {
  values: string[],
};
export type FrameSetContentParams = {
  html: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentResult = void;
export type FrameSetInputFilesParams = {
  selector: string,
  files: {
    name: string,
    mimeType: string,
    buffer: types.Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesResult = void;
export type FrameTapParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameTapResult = void;
export type FrameTextContentParams = {
  selector: string,
  timeout?: number,
};
export type FrameTextContentOptions = {
  timeout?: number,
};
export type FrameTextContentResult = {
  value?: string,
};
export type FrameTitleParams = {};
export type FrameTitleOptions = {};
export type FrameTitleResult = {
  value: string,
};
export type FrameTypeParams = {
  selector: string,
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeResult = void;
export type FrameUncheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckResult = void;
export type FrameWaitForFunctionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionOptions = {
  isFunction?: boolean,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionResult = {
  handle: JSHandleChannel,
};
export type FrameWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Worker -----------
export type WorkerInitializer = {
  url: string,
};
export interface WorkerChannel extends Channel {
  evaluateExpression(params: WorkerEvaluateExpressionParams, metadata?: CallMetadata): Promise<WorkerEvaluateExpressionResult>;
  evaluateExpressionHandle(params: WorkerEvaluateExpressionHandleParams, metadata?: CallMetadata): Promise<WorkerEvaluateExpressionHandleResult>;
}
export type WorkerCloseEvent = {};
export type WorkerEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type WorkerEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type WorkerEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type WorkerEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type WorkerEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type WorkerEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};

// ----------- JSHandle -----------
export type JSHandleInitializer = {
  preview: string,
};
export interface JSHandleChannel extends Channel {
  dispose(params?: JSHandleDisposeParams, metadata?: CallMetadata): Promise<JSHandleDisposeResult>;
  evaluateExpression(params: JSHandleEvaluateExpressionParams, metadata?: CallMetadata): Promise<JSHandleEvaluateExpressionResult>;
  evaluateExpressionHandle(params: JSHandleEvaluateExpressionHandleParams, metadata?: CallMetadata): Promise<JSHandleEvaluateExpressionHandleResult>;
  getPropertyList(params?: JSHandleGetPropertyListParams, metadata?: CallMetadata): Promise<JSHandleGetPropertyListResult>;
  getProperty(params: JSHandleGetPropertyParams, metadata?: CallMetadata): Promise<JSHandleGetPropertyResult>;
  jsonValue(params?: JSHandleJsonValueParams, metadata?: CallMetadata): Promise<JSHandleJsonValueResult>;
}
export type JSHandlePreviewUpdatedEvent = {
  preview: string,
};
export type JSHandleDisposeParams = {};
export type JSHandleDisposeOptions = {};
export type JSHandleDisposeResult = void;
export type JSHandleEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type JSHandleEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type JSHandleEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type JSHandleEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type JSHandleEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type JSHandleEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type JSHandleGetPropertyListParams = {};
export type JSHandleGetPropertyListOptions = {};
export type JSHandleGetPropertyListResult = {
  properties: {
    name: string,
    value: JSHandleChannel,
  }[],
};
export type JSHandleGetPropertyParams = {
  name: string,
};
export type JSHandleGetPropertyOptions = {

};
export type JSHandleGetPropertyResult = {
  handle: JSHandleChannel,
};
export type JSHandleJsonValueParams = {};
export type JSHandleJsonValueOptions = {};
export type JSHandleJsonValueResult = {
  value: types.SerializedValue,
};

// ----------- ElementHandle -----------
export type ElementHandleInitializer = {};
export interface ElementHandleChannel extends JSHandleChannel {
  evalOnSelector(params: ElementHandleEvalOnSelectorParams, metadata?: CallMetadata): Promise<ElementHandleEvalOnSelectorResult>;
  evalOnSelectorAll(params: ElementHandleEvalOnSelectorAllParams, metadata?: CallMetadata): Promise<ElementHandleEvalOnSelectorAllResult>;
  boundingBox(params?: ElementHandleBoundingBoxParams, metadata?: CallMetadata): Promise<ElementHandleBoundingBoxResult>;
  check(params: ElementHandleCheckParams, metadata?: CallMetadata): Promise<ElementHandleCheckResult>;
  click(params: ElementHandleClickParams, metadata?: CallMetadata): Promise<ElementHandleClickResult>;
  contentFrame(params?: ElementHandleContentFrameParams, metadata?: CallMetadata): Promise<ElementHandleContentFrameResult>;
  dblclick(params: ElementHandleDblclickParams, metadata?: CallMetadata): Promise<ElementHandleDblclickResult>;
  dispatchEvent(params: ElementHandleDispatchEventParams, metadata?: CallMetadata): Promise<ElementHandleDispatchEventResult>;
  fill(params: ElementHandleFillParams, metadata?: CallMetadata): Promise<ElementHandleFillResult>;
  focus(params?: ElementHandleFocusParams, metadata?: CallMetadata): Promise<ElementHandleFocusResult>;
  getAttribute(params: ElementHandleGetAttributeParams, metadata?: CallMetadata): Promise<ElementHandleGetAttributeResult>;
  hover(params: ElementHandleHoverParams, metadata?: CallMetadata): Promise<ElementHandleHoverResult>;
  innerHTML(params?: ElementHandleInnerHTMLParams, metadata?: CallMetadata): Promise<ElementHandleInnerHTMLResult>;
  innerText(params?: ElementHandleInnerTextParams, metadata?: CallMetadata): Promise<ElementHandleInnerTextResult>;
  isChecked(params?: ElementHandleIsCheckedParams, metadata?: CallMetadata): Promise<ElementHandleIsCheckedResult>;
  isDisabled(params?: ElementHandleIsDisabledParams, metadata?: CallMetadata): Promise<ElementHandleIsDisabledResult>;
  isEditable(params?: ElementHandleIsEditableParams, metadata?: CallMetadata): Promise<ElementHandleIsEditableResult>;
  isEnabled(params?: ElementHandleIsEnabledParams, metadata?: CallMetadata): Promise<ElementHandleIsEnabledResult>;
  isHidden(params?: ElementHandleIsHiddenParams, metadata?: CallMetadata): Promise<ElementHandleIsHiddenResult>;
  isVisible(params?: ElementHandleIsVisibleParams, metadata?: CallMetadata): Promise<ElementHandleIsVisibleResult>;
  ownerFrame(params?: ElementHandleOwnerFrameParams, metadata?: CallMetadata): Promise<ElementHandleOwnerFrameResult>;
  press(params: ElementHandlePressParams, metadata?: CallMetadata): Promise<ElementHandlePressResult>;
  querySelector(params: ElementHandleQuerySelectorParams, metadata?: CallMetadata): Promise<ElementHandleQuerySelectorResult>;
  querySelectorAll(params: ElementHandleQuerySelectorAllParams, metadata?: CallMetadata): Promise<ElementHandleQuerySelectorAllResult>;
  screenshot(params: ElementHandleScreenshotParams, metadata?: CallMetadata): Promise<ElementHandleScreenshotResult>;
  scrollIntoViewIfNeeded(params: ElementHandleScrollIntoViewIfNeededParams, metadata?: CallMetadata): Promise<ElementHandleScrollIntoViewIfNeededResult>;
  selectOption(params: ElementHandleSelectOptionParams, metadata?: CallMetadata): Promise<ElementHandleSelectOptionResult>;
  selectText(params: ElementHandleSelectTextParams, metadata?: CallMetadata): Promise<ElementHandleSelectTextResult>;
  setInputFiles(params: ElementHandleSetInputFilesParams, metadata?: CallMetadata): Promise<ElementHandleSetInputFilesResult>;
  tap(params: ElementHandleTapParams, metadata?: CallMetadata): Promise<ElementHandleTapResult>;
  textContent(params?: ElementHandleTextContentParams, metadata?: CallMetadata): Promise<ElementHandleTextContentResult>;
  type(params: ElementHandleTypeParams, metadata?: CallMetadata): Promise<ElementHandleTypeResult>;
  uncheck(params: ElementHandleUncheckParams, metadata?: CallMetadata): Promise<ElementHandleUncheckResult>;
  waitForElementState(params: ElementHandleWaitForElementStateParams, metadata?: CallMetadata): Promise<ElementHandleWaitForElementStateResult>;
  waitForSelector(params: ElementHandleWaitForSelectorParams, metadata?: CallMetadata): Promise<ElementHandleWaitForSelectorResult>;
}
export type ElementHandleEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElementHandleEvalOnSelectorOptions = {
  isFunction?: boolean,
};
export type ElementHandleEvalOnSelectorResult = {
  value: types.SerializedValue,
};
export type ElementHandleEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElementHandleEvalOnSelectorAllOptions = {
  isFunction?: boolean,
};
export type ElementHandleEvalOnSelectorAllResult = {
  value: types.SerializedValue,
};
export type ElementHandleBoundingBoxParams = {};
export type ElementHandleBoundingBoxOptions = {};
export type ElementHandleBoundingBoxResult = {
  value?: types.Rect,
};
export type ElementHandleCheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckResult = void;
export type ElementHandleClickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickResult = void;
export type ElementHandleContentFrameParams = {};
export type ElementHandleContentFrameOptions = {};
export type ElementHandleContentFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandleDblclickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickResult = void;
export type ElementHandleDispatchEventParams = {
  type: string,
  eventInit: types.SerializedArgument,
};
export type ElementHandleDispatchEventOptions = {

};
export type ElementHandleDispatchEventResult = void;
export type ElementHandleFillParams = {
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillResult = void;
export type ElementHandleFocusParams = {};
export type ElementHandleFocusOptions = {};
export type ElementHandleFocusResult = void;
export type ElementHandleGetAttributeParams = {
  name: string,
};
export type ElementHandleGetAttributeOptions = {

};
export type ElementHandleGetAttributeResult = {
  value?: string,
};
export type ElementHandleHoverParams = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleHoverResult = void;
export type ElementHandleInnerHTMLParams = {};
export type ElementHandleInnerHTMLOptions = {};
export type ElementHandleInnerHTMLResult = {
  value: string,
};
export type ElementHandleInnerTextParams = {};
export type ElementHandleInnerTextOptions = {};
export type ElementHandleInnerTextResult = {
  value: string,
};
export type ElementHandleIsCheckedParams = {};
export type ElementHandleIsCheckedOptions = {};
export type ElementHandleIsCheckedResult = {
  value: boolean,
};
export type ElementHandleIsDisabledParams = {};
export type ElementHandleIsDisabledOptions = {};
export type ElementHandleIsDisabledResult = {
  value: boolean,
};
export type ElementHandleIsEditableParams = {};
export type ElementHandleIsEditableOptions = {};
export type ElementHandleIsEditableResult = {
  value: boolean,
};
export type ElementHandleIsEnabledParams = {};
export type ElementHandleIsEnabledOptions = {};
export type ElementHandleIsEnabledResult = {
  value: boolean,
};
export type ElementHandleIsHiddenParams = {};
export type ElementHandleIsHiddenOptions = {};
export type ElementHandleIsHiddenResult = {
  value: boolean,
};
export type ElementHandleIsVisibleParams = {};
export type ElementHandleIsVisibleOptions = {};
export type ElementHandleIsVisibleResult = {
  value: boolean,
};
export type ElementHandleOwnerFrameParams = {};
export type ElementHandleOwnerFrameOptions = {};
export type ElementHandleOwnerFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandlePressParams = {
  key: string,
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressOptions = {
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressResult = void;
export type ElementHandleQuerySelectorParams = {
  selector: string,
};
export type ElementHandleQuerySelectorOptions = {

};
export type ElementHandleQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type ElementHandleQuerySelectorAllParams = {
  selector: string,
};
export type ElementHandleQuerySelectorAllOptions = {

};
export type ElementHandleQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type ElementHandleScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotResult = {
  binary: types.Binary,
};
export type ElementHandleScrollIntoViewIfNeededParams = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededOptions = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededResult = void;
export type ElementHandleSelectOptionParams = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionResult = {
  values: string[],
};
export type ElementHandleSelectTextParams = {
  timeout?: number,
};
export type ElementHandleSelectTextOptions = {
  timeout?: number,
};
export type ElementHandleSelectTextResult = void;
export type ElementHandleSetInputFilesParams = {
  files: {
    name: string,
    mimeType: string,
    buffer: types.Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesResult = void;
export type ElementHandleTapParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleTapResult = void;
export type ElementHandleTextContentParams = {};
export type ElementHandleTextContentOptions = {};
export type ElementHandleTextContentResult = {
  value?: string,
};
export type ElementHandleTypeParams = {
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeResult = void;
export type ElementHandleUncheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckResult = void;
export type ElementHandleWaitForElementStateParams = {
  state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled' | 'editable',
  timeout?: number,
};
export type ElementHandleWaitForElementStateOptions = {
  timeout?: number,
};
export type ElementHandleWaitForElementStateResult = void;
export type ElementHandleWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Request -----------
export type RequestInitializer = {
  frame: FrameChannel,
  url: string,
  resourceType: string,
  method: string,
  postData?: types.Binary,
  headers: {
    name: string,
    value: string,
  }[],
  isNavigationRequest: boolean,
  redirectedFrom?: RequestChannel,
};
export interface RequestChannel extends Channel {
  response(params?: RequestResponseParams, metadata?: CallMetadata): Promise<RequestResponseResult>;
}
export type RequestResponseParams = {};
export type RequestResponseOptions = {};
export type RequestResponseResult = {
  response?: ResponseChannel,
};

// ----------- Route -----------
export type RouteInitializer = {
  request: RequestChannel,
};
export interface RouteChannel extends Channel {
  abort(params: RouteAbortParams, metadata?: CallMetadata): Promise<RouteAbortResult>;
  continue(params: RouteContinueParams, metadata?: CallMetadata): Promise<RouteContinueResult>;
  fulfill(params: RouteFulfillParams, metadata?: CallMetadata): Promise<RouteFulfillResult>;
}
export type RouteAbortParams = {
  errorCode?: string,
};
export type RouteAbortOptions = {
  errorCode?: string,
};
export type RouteAbortResult = void;
export type RouteContinueParams = {
  url?: string,
  method?: string,
  headers?: types.NameValue[],
  postData?: types.Binary,
};
export type RouteContinueOptions = {
  url?: string,
  method?: string,
  headers?: types.NameValue[],
  postData?: types.Binary,
};
export type RouteContinueResult = void;
export type RouteFulfillParams = {
  status?: number,
  headers?: types.NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillOptions = {
  status?: number,
  headers?: types.NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillResult = void;

// ----------- Response -----------
export type ResponseInitializer = {
  request: RequestChannel,
  url: string,
  status: number,
  statusText: string,
  requestHeaders: {
    name: string,
    value: string,
  }[],
  headers: {
    name: string,
    value: string,
  }[],
  timing: types.ResourceTiming,
};
export interface ResponseChannel extends Channel {
  body(params?: ResponseBodyParams, metadata?: CallMetadata): Promise<ResponseBodyResult>;
  finished(params?: ResponseFinishedParams, metadata?: CallMetadata): Promise<ResponseFinishedResult>;
}
export type ResponseBodyParams = {};
export type ResponseBodyOptions = {};
export type ResponseBodyResult = {
  binary: types.Binary,
};
export type ResponseFinishedParams = {};
export type ResponseFinishedOptions = {};
export type ResponseFinishedResult = {
  error?: string,
};

// ----------- WebSocket -----------
export type WebSocketInitializer = {
  url: string,
};
export interface WebSocketChannel extends Channel {
}
export type WebSocketOpenEvent = {};
export type WebSocketFrameSentEvent = {
  opcode: number,
  data: string,
};
export type WebSocketFrameReceivedEvent = {
  opcode: number,
  data: string,
};
export type WebSocketSocketErrorEvent = {
  error: string,
};
export type WebSocketCloseEvent = {};

// ----------- ConsoleMessage -----------
export type ConsoleMessageInitializer = {
  type: string,
  text: string,
  args: JSHandleChannel[],
  location: {
    url: string,
    lineNumber: number,
    columnNumber: number,
  },
};
export interface ConsoleMessageChannel extends Channel {
}

// ----------- BindingCall -----------
export type BindingCallInitializer = {
  frame: FrameChannel,
  name: string,
  args?: types.SerializedValue[],
  handle?: JSHandleChannel,
};
export interface BindingCallChannel extends Channel {
  reject(params: BindingCallRejectParams, metadata?: CallMetadata): Promise<BindingCallRejectResult>;
  resolve(params: BindingCallResolveParams, metadata?: CallMetadata): Promise<BindingCallResolveResult>;
}
export type BindingCallRejectParams = {
  error: types.SerializedError,
};
export type BindingCallRejectOptions = {

};
export type BindingCallRejectResult = void;
export type BindingCallResolveParams = {
  result: types.SerializedArgument,
};
export type BindingCallResolveOptions = {

};
export type BindingCallResolveResult = void;

// ----------- Dialog -----------
export type DialogInitializer = {
  type: string,
  message: string,
  defaultValue: string,
};
export interface DialogChannel extends Channel {
  accept(params: DialogAcceptParams, metadata?: CallMetadata): Promise<DialogAcceptResult>;
  dismiss(params?: DialogDismissParams, metadata?: CallMetadata): Promise<DialogDismissResult>;
}
export type DialogAcceptParams = {
  promptText?: string,
};
export type DialogAcceptOptions = {
  promptText?: string,
};
export type DialogAcceptResult = void;
export type DialogDismissParams = {};
export type DialogDismissOptions = {};
export type DialogDismissResult = void;

// ----------- Download -----------
export type DownloadInitializer = {
  url: string,
  suggestedFilename: string,
};
export interface DownloadChannel extends Channel {
  path(params?: DownloadPathParams, metadata?: CallMetadata): Promise<DownloadPathResult>;
  saveAs(params: DownloadSaveAsParams, metadata?: CallMetadata): Promise<DownloadSaveAsResult>;
  saveAsStream(params?: DownloadSaveAsStreamParams, metadata?: CallMetadata): Promise<DownloadSaveAsStreamResult>;
  failure(params?: DownloadFailureParams, metadata?: CallMetadata): Promise<DownloadFailureResult>;
  stream(params?: DownloadStreamParams, metadata?: CallMetadata): Promise<DownloadStreamResult>;
  delete(params?: DownloadDeleteParams, metadata?: CallMetadata): Promise<DownloadDeleteResult>;
}
export type DownloadPathParams = {};
export type DownloadPathOptions = {};
export type DownloadPathResult = {
  value?: string,
};
export type DownloadSaveAsParams = {
  path: string,
};
export type DownloadSaveAsOptions = {

};
export type DownloadSaveAsResult = void;
export type DownloadSaveAsStreamParams = {};
export type DownloadSaveAsStreamOptions = {};
export type DownloadSaveAsStreamResult = {
  stream: StreamChannel,
};
export type DownloadFailureParams = {};
export type DownloadFailureOptions = {};
export type DownloadFailureResult = {
  error?: string,
};
export type DownloadStreamParams = {};
export type DownloadStreamOptions = {};
export type DownloadStreamResult = {
  stream?: StreamChannel,
};
export type DownloadDeleteParams = {};
export type DownloadDeleteOptions = {};
export type DownloadDeleteResult = void;

// ----------- Stream -----------
export type StreamInitializer = {};
export interface StreamChannel extends Channel {
  read(params: StreamReadParams, metadata?: CallMetadata): Promise<StreamReadResult>;
  close(params?: StreamCloseParams, metadata?: CallMetadata): Promise<StreamCloseResult>;
}
export type StreamReadParams = {
  size?: number,
};
export type StreamReadOptions = {
  size?: number,
};
export type StreamReadResult = {
  binary: types.Binary,
};
export type StreamCloseParams = {};
export type StreamCloseOptions = {};
export type StreamCloseResult = void;

// ----------- CDPSession -----------
export type CDPSessionInitializer = {};
export interface CDPSessionChannel extends Channel {
  send(params: CDPSessionSendParams, metadata?: CallMetadata): Promise<CDPSessionSendResult>;
  detach(params?: CDPSessionDetachParams, metadata?: CallMetadata): Promise<CDPSessionDetachResult>;
}
export type CDPSessionEventEvent = {
  method: string,
  params?: any,
};
export type CDPSessionSendParams = {
  method: string,
  params?: any,
};
export type CDPSessionSendOptions = {
  params?: any,
};
export type CDPSessionSendResult = {
  result: any,
};
export type CDPSessionDetachParams = {};
export type CDPSessionDetachOptions = {};
export type CDPSessionDetachResult = void;

// ----------- Electron -----------
export type ElectronInitializer = {};
export interface ElectronChannel extends Channel {
  launch(params: ElectronLaunchParams, metadata?: CallMetadata): Promise<ElectronLaunchResult>;
}
export type ElectronLaunchParams = {
  sdkLanguage: string,
  executablePath?: string,
  args?: string[],
  cwd?: string,
  env?: types.NameValue[],
  timeout?: number,
};
export type ElectronLaunchOptions = {
  executablePath?: string,
  args?: string[],
  cwd?: string,
  env?: types.NameValue[],
  timeout?: number,
};
export type ElectronLaunchResult = {
  electronApplication: ElectronApplicationChannel,
};

// ----------- ElectronApplication -----------
export type ElectronApplicationInitializer = {};
export interface ElectronApplicationChannel extends Channel {
  evaluateExpression(params: ElectronApplicationEvaluateExpressionParams, metadata?: CallMetadata): Promise<ElectronApplicationEvaluateExpressionResult>;
  evaluateExpressionHandle(params: ElectronApplicationEvaluateExpressionHandleParams, metadata?: CallMetadata): Promise<ElectronApplicationEvaluateExpressionHandleResult>;
  close(params?: ElectronApplicationCloseParams, metadata?: CallMetadata): Promise<ElectronApplicationCloseResult>;
}
export type ElectronApplicationContextEvent = {
  context: BrowserContextChannel,
};
export type ElectronApplicationCloseEvent = {};
export type ElectronApplicationWindowEvent = {
  page: PageChannel,
  browserWindow: JSHandleChannel,
};
export type ElectronApplicationEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type ElectronApplicationEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type ElectronApplicationEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type ElectronApplicationEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type ElectronApplicationCloseParams = {};
export type ElectronApplicationCloseOptions = {};
export type ElectronApplicationCloseResult = void;

// ----------- Android -----------
export type AndroidInitializer = {};
export interface AndroidChannel extends Channel {
  devices(params?: AndroidDevicesParams, metadata?: CallMetadata): Promise<AndroidDevicesResult>;
  setDefaultTimeoutNoReply(params: AndroidSetDefaultTimeoutNoReplyParams, metadata?: CallMetadata): Promise<AndroidSetDefaultTimeoutNoReplyResult>;
}
export type AndroidDevicesParams = {};
export type AndroidDevicesOptions = {};
export type AndroidDevicesResult = {
  devices: AndroidDeviceChannel[],
};
export type AndroidSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidSetDefaultTimeoutNoReplyResult = void;

// ----------- AndroidSocket -----------
export type AndroidSocketInitializer = {};
export interface AndroidSocketChannel extends Channel {
  write(params: AndroidSocketWriteParams, metadata?: CallMetadata): Promise<AndroidSocketWriteResult>;
  close(params?: AndroidSocketCloseParams, metadata?: CallMetadata): Promise<AndroidSocketCloseResult>;
}
export type AndroidSocketDataEvent = {
  data: types.Binary,
};
export type AndroidSocketCloseEvent = {};
export type AndroidSocketWriteParams = {
  data: types.Binary,
};
export type AndroidSocketWriteOptions = {

};
export type AndroidSocketWriteResult = void;
export type AndroidSocketCloseParams = {};
export type AndroidSocketCloseOptions = {};
export type AndroidSocketCloseResult = void;

// ----------- AndroidDevice -----------
export type AndroidDeviceInitializer = {
  model: string,
  serial: string,
};
export interface AndroidDeviceChannel extends Channel {
  wait(params: AndroidDeviceWaitParams, metadata?: CallMetadata): Promise<AndroidDeviceWaitResult>;
  fill(params: AndroidDeviceFillParams, metadata?: CallMetadata): Promise<AndroidDeviceFillResult>;
  tap(params: AndroidDeviceTapParams, metadata?: CallMetadata): Promise<AndroidDeviceTapResult>;
  drag(params: AndroidDeviceDragParams, metadata?: CallMetadata): Promise<AndroidDeviceDragResult>;
  fling(params: AndroidDeviceFlingParams, metadata?: CallMetadata): Promise<AndroidDeviceFlingResult>;
  longTap(params: AndroidDeviceLongTapParams, metadata?: CallMetadata): Promise<AndroidDeviceLongTapResult>;
  pinchClose(params: AndroidDevicePinchCloseParams, metadata?: CallMetadata): Promise<AndroidDevicePinchCloseResult>;
  pinchOpen(params: AndroidDevicePinchOpenParams, metadata?: CallMetadata): Promise<AndroidDevicePinchOpenResult>;
  scroll(params: AndroidDeviceScrollParams, metadata?: CallMetadata): Promise<AndroidDeviceScrollResult>;
  swipe(params: AndroidDeviceSwipeParams, metadata?: CallMetadata): Promise<AndroidDeviceSwipeResult>;
  info(params: AndroidDeviceInfoParams, metadata?: CallMetadata): Promise<AndroidDeviceInfoResult>;
  screenshot(params?: AndroidDeviceScreenshotParams, metadata?: CallMetadata): Promise<AndroidDeviceScreenshotResult>;
  inputType(params: AndroidDeviceInputTypeParams, metadata?: CallMetadata): Promise<AndroidDeviceInputTypeResult>;
  inputPress(params: AndroidDeviceInputPressParams, metadata?: CallMetadata): Promise<AndroidDeviceInputPressResult>;
  inputTap(params: AndroidDeviceInputTapParams, metadata?: CallMetadata): Promise<AndroidDeviceInputTapResult>;
  inputSwipe(params: AndroidDeviceInputSwipeParams, metadata?: CallMetadata): Promise<AndroidDeviceInputSwipeResult>;
  inputDrag(params: AndroidDeviceInputDragParams, metadata?: CallMetadata): Promise<AndroidDeviceInputDragResult>;
  launchBrowser(params: AndroidDeviceLaunchBrowserParams, metadata?: CallMetadata): Promise<AndroidDeviceLaunchBrowserResult>;
  open(params: AndroidDeviceOpenParams, metadata?: CallMetadata): Promise<AndroidDeviceOpenResult>;
  shell(params: AndroidDeviceShellParams, metadata?: CallMetadata): Promise<AndroidDeviceShellResult>;
  installApk(params: AndroidDeviceInstallApkParams, metadata?: CallMetadata): Promise<AndroidDeviceInstallApkResult>;
  push(params: AndroidDevicePushParams, metadata?: CallMetadata): Promise<AndroidDevicePushResult>;
  setDefaultTimeoutNoReply(params: AndroidDeviceSetDefaultTimeoutNoReplyParams, metadata?: CallMetadata): Promise<AndroidDeviceSetDefaultTimeoutNoReplyResult>;
  connectToWebView(params: AndroidDeviceConnectToWebViewParams, metadata?: CallMetadata): Promise<AndroidDeviceConnectToWebViewResult>;
  close(params?: AndroidDeviceCloseParams, metadata?: CallMetadata): Promise<AndroidDeviceCloseResult>;
}
export type AndroidDeviceWebViewAddedEvent = {
  webView: types.AndroidWebView,
};
export type AndroidDeviceWebViewRemovedEvent = {
  pid: number,
};
export type AndroidDeviceWaitParams = {
  selector: types.AndroidSelector,
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitOptions = {
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitResult = void;
export type AndroidDeviceFillParams = {
  selector: types.AndroidSelector,
  text: string,
  timeout?: number,
};
export type AndroidDeviceFillOptions = {
  timeout?: number,
};
export type AndroidDeviceFillResult = void;
export type AndroidDeviceTapParams = {
  selector: types.AndroidSelector,
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapOptions = {
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapResult = void;
export type AndroidDeviceDragParams = {
  selector: types.AndroidSelector,
  dest: types.Point,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragResult = void;
export type AndroidDeviceFlingParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingResult = void;
export type AndroidDeviceLongTapParams = {
  selector: types.AndroidSelector,
  timeout?: number,
};
export type AndroidDeviceLongTapOptions = {
  timeout?: number,
};
export type AndroidDeviceLongTapResult = void;
export type AndroidDevicePinchCloseParams = {
  selector: types.AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseResult = void;
export type AndroidDevicePinchOpenParams = {
  selector: types.AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenResult = void;
export type AndroidDeviceScrollParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollResult = void;
export type AndroidDeviceSwipeParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeResult = void;
export type AndroidDeviceInfoParams = {
  selector: types.AndroidSelector,
};
export type AndroidDeviceInfoOptions = {

};
export type AndroidDeviceInfoResult = {
  info: types.AndroidElementInfo,
};
export type AndroidDeviceScreenshotParams = {};
export type AndroidDeviceScreenshotOptions = {};
export type AndroidDeviceScreenshotResult = {
  binary: types.Binary,
};
export type AndroidDeviceInputTypeParams = {
  text: string,
};
export type AndroidDeviceInputTypeOptions = {

};
export type AndroidDeviceInputTypeResult = void;
export type AndroidDeviceInputPressParams = {
  key: string,
};
export type AndroidDeviceInputPressOptions = {

};
export type AndroidDeviceInputPressResult = void;
export type AndroidDeviceInputTapParams = {
  point: types.Point,
};
export type AndroidDeviceInputTapOptions = {

};
export type AndroidDeviceInputTapResult = void;
export type AndroidDeviceInputSwipeParams = {
  segments: types.Point[],
  steps: number,
};
export type AndroidDeviceInputSwipeOptions = {

};
export type AndroidDeviceInputSwipeResult = void;
export type AndroidDeviceInputDragParams = {
  from: types.Point,
  to: types.Point,
  steps: number,
};
export type AndroidDeviceInputDragOptions = {

};
export type AndroidDeviceInputDragResult = void;
export type AndroidDeviceLaunchBrowserParams = {
  sdkLanguage: string,
  pkg?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserOptions = {
  pkg?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceOpenParams = {
  command: string,
};
export type AndroidDeviceOpenOptions = {

};
export type AndroidDeviceOpenResult = {
  socket: AndroidSocketChannel,
};
export type AndroidDeviceShellParams = {
  command: string,
};
export type AndroidDeviceShellOptions = {

};
export type AndroidDeviceShellResult = {
  result: types.Binary,
};
export type AndroidDeviceInstallApkParams = {
  file: types.Binary,
  args?: string[],
};
export type AndroidDeviceInstallApkOptions = {
  args?: string[],
};
export type AndroidDeviceInstallApkResult = void;
export type AndroidDevicePushParams = {
  file: types.Binary,
  path: string,
  mode?: number,
};
export type AndroidDevicePushOptions = {
  mode?: number,
};
export type AndroidDevicePushResult = void;
export type AndroidDeviceSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidDeviceSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidDeviceSetDefaultTimeoutNoReplyResult = void;
export type AndroidDeviceConnectToWebViewParams = {
  sdkLanguage: string,
  pid: number,
};
export type AndroidDeviceConnectToWebViewOptions = {

};
export type AndroidDeviceConnectToWebViewResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceCloseParams = {};
export type AndroidDeviceCloseOptions = {};
export type AndroidDeviceCloseResult = void;
