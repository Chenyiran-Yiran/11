/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is generated by generate_channels.js, do not edit manually.

import { EventEmitter } from 'events';
import * as types from '../protocol/types';
import { Progress } from '../server/progress';
export * from '../protocol/types';

export interface Channel extends EventEmitter {
}

// ----------- Playwright -----------
export type PlaywrightInitializer = {
  chromium: BrowserTypeChannel,
  firefox: BrowserTypeChannel,
  webkit: BrowserTypeChannel,
  android: AndroidChannel,
  electron: ElectronChannel,
  deviceDescriptors: {
    name: string,
    descriptor: {
      userAgent: string,
      viewport: {
        width: number,
        height: number,
      },
      deviceScaleFactor: number,
      isMobile: boolean,
      hasTouch: boolean,
      defaultBrowserType: 'chromium' | 'firefox' | 'webkit',
    },
  }[],
  selectors: SelectorsChannel,
};
export interface PlaywrightChannel extends Channel {
}

// ----------- RemoteBrowser -----------
export type RemoteBrowserInitializer = {
  browser: BrowserChannel,
  selectors: SelectorsChannel,
};
export interface RemoteBrowserChannel extends Channel {
}
export type RemoteBrowserVideoEvent = {
  context: BrowserContextChannel,
  stream: StreamChannel,
  relativePath: string,
};

// ----------- Selectors -----------
export type SelectorsInitializer = {};
export interface SelectorsChannel extends Channel {
  register(progress: Progress, params: SelectorsRegisterParams): Promise<SelectorsRegisterResult>;
}
export type SelectorsRegisterParams = {
  name: string,
  source: string,
  contentScript?: boolean,
};
export type SelectorsRegisterOptions = {
  contentScript?: boolean,
};
export type SelectorsRegisterResult = void;

// ----------- BrowserType -----------
export type BrowserTypeInitializer = {
  executablePath: string,
  name: string,
};
export interface BrowserTypeChannel extends Channel {
  launch(progress: Progress, params: BrowserTypeLaunchParams): Promise<BrowserTypeLaunchResult>;
  launchPersistentContext(progress: Progress, params: BrowserTypeLaunchPersistentContextParams): Promise<BrowserTypeLaunchPersistentContextResult>;
  connectOverCDP(progress: Progress, params: BrowserTypeConnectOverCDPParams): Promise<BrowserTypeConnectOverCDPResult>;
}
export type BrowserTypeLaunchParams = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchResult = {
  browser: BrowserChannel,
};
export type BrowserTypeLaunchPersistentContextParams = {
  userDataDir: string,
  sdkLanguage: string,
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: types.NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextResult = {
  context: BrowserContextChannel,
};
export type BrowserTypeConnectOverCDPParams = {
  sdkLanguage: string,
  wsEndpoint: string,
  slowMo?: number,
  timeout?: number,
};
export type BrowserTypeConnectOverCDPOptions = {
  slowMo?: number,
  timeout?: number,
};
export type BrowserTypeConnectOverCDPResult = {
  browser: BrowserChannel,
  defaultContext?: BrowserContextChannel,
};

// ----------- Browser -----------
export type BrowserInitializer = {
  version: string,
  name: string,
};
export interface BrowserChannel extends Channel {
  close(progress: Progress, params?: BrowserCloseParams): Promise<BrowserCloseResult>;
  newContext(progress: Progress, params: BrowserNewContextParams): Promise<BrowserNewContextResult>;
  crNewBrowserCDPSession(progress: Progress, params?: BrowserCrNewBrowserCDPSessionParams): Promise<BrowserCrNewBrowserCDPSessionResult>;
  crStartTracing(progress: Progress, params: BrowserCrStartTracingParams): Promise<BrowserCrStartTracingResult>;
  crStopTracing(progress: Progress, params?: BrowserCrStopTracingParams): Promise<BrowserCrStopTracingResult>;
}
export type BrowserCloseEvent = {};
export type BrowserCloseParams = {};
export type BrowserCloseOptions = {};
export type BrowserCloseResult = void;
export type BrowserNewContextParams = {
  sdkLanguage: string,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: types.SetNetworkCookie[],
    origins?: types.OriginStorage[],
  },
};
export type BrowserNewContextOptions = {
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: types.SetNetworkCookie[],
    origins?: types.OriginStorage[],
  },
};
export type BrowserNewContextResult = {
  context: BrowserContextChannel,
};
export type BrowserCrNewBrowserCDPSessionParams = {};
export type BrowserCrNewBrowserCDPSessionOptions = {};
export type BrowserCrNewBrowserCDPSessionResult = {
  session: CDPSessionChannel,
};
export type BrowserCrStartTracingParams = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingOptions = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingResult = void;
export type BrowserCrStopTracingParams = {};
export type BrowserCrStopTracingOptions = {};
export type BrowserCrStopTracingResult = {
  binary: types.Binary,
};

// ----------- BrowserContext -----------
export type BrowserContextInitializer = {
  isChromium: boolean,
};
export interface BrowserContextChannel extends Channel {
  addCookies(progress: Progress, params: BrowserContextAddCookiesParams): Promise<BrowserContextAddCookiesResult>;
  addInitScript(progress: Progress, params: BrowserContextAddInitScriptParams): Promise<BrowserContextAddInitScriptResult>;
  clearCookies(progress: Progress, params?: BrowserContextClearCookiesParams): Promise<BrowserContextClearCookiesResult>;
  clearPermissions(progress: Progress, params?: BrowserContextClearPermissionsParams): Promise<BrowserContextClearPermissionsResult>;
  close(progress: Progress, params?: BrowserContextCloseParams): Promise<BrowserContextCloseResult>;
  cookies(progress: Progress, params: BrowserContextCookiesParams): Promise<BrowserContextCookiesResult>;
  exposeBinding(progress: Progress, params: BrowserContextExposeBindingParams): Promise<BrowserContextExposeBindingResult>;
  grantPermissions(progress: Progress, params: BrowserContextGrantPermissionsParams): Promise<BrowserContextGrantPermissionsResult>;
  newPage(progress: Progress, params?: BrowserContextNewPageParams): Promise<BrowserContextNewPageResult>;
  setDefaultNavigationTimeoutNoReply(progress: Progress, params: BrowserContextSetDefaultNavigationTimeoutNoReplyParams): Promise<BrowserContextSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(progress: Progress, params: BrowserContextSetDefaultTimeoutNoReplyParams): Promise<BrowserContextSetDefaultTimeoutNoReplyResult>;
  setExtraHTTPHeaders(progress: Progress, params: BrowserContextSetExtraHTTPHeadersParams): Promise<BrowserContextSetExtraHTTPHeadersResult>;
  setGeolocation(progress: Progress, params: BrowserContextSetGeolocationParams): Promise<BrowserContextSetGeolocationResult>;
  setHTTPCredentials(progress: Progress, params: BrowserContextSetHTTPCredentialsParams): Promise<BrowserContextSetHTTPCredentialsResult>;
  setNetworkInterceptionEnabled(progress: Progress, params: BrowserContextSetNetworkInterceptionEnabledParams): Promise<BrowserContextSetNetworkInterceptionEnabledResult>;
  setOffline(progress: Progress, params: BrowserContextSetOfflineParams): Promise<BrowserContextSetOfflineResult>;
  storageState(progress: Progress, params?: BrowserContextStorageStateParams): Promise<BrowserContextStorageStateResult>;
  pause(progress: Progress, params?: BrowserContextPauseParams): Promise<BrowserContextPauseResult>;
  recorderSupplementEnable(progress: Progress, params: BrowserContextRecorderSupplementEnableParams): Promise<BrowserContextRecorderSupplementEnableResult>;
  crNewCDPSession(progress: Progress, params: BrowserContextCrNewCDPSessionParams): Promise<BrowserContextCrNewCDPSessionResult>;
}
export type BrowserContextBindingCallEvent = {
  binding: BindingCallChannel,
};
export type BrowserContextCloseEvent = {};
export type BrowserContextPageEvent = {
  page: PageChannel,
};
export type BrowserContextRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type BrowserContextCrBackgroundPageEvent = {
  page: PageChannel,
};
export type BrowserContextCrServiceWorkerEvent = {
  worker: WorkerChannel,
};
export type BrowserContextAddCookiesParams = {
  cookies: types.SetNetworkCookie[],
};
export type BrowserContextAddCookiesOptions = {

};
export type BrowserContextAddCookiesResult = void;
export type BrowserContextAddInitScriptParams = {
  source: string,
};
export type BrowserContextAddInitScriptOptions = {

};
export type BrowserContextAddInitScriptResult = void;
export type BrowserContextClearCookiesParams = {};
export type BrowserContextClearCookiesOptions = {};
export type BrowserContextClearCookiesResult = void;
export type BrowserContextClearPermissionsParams = {};
export type BrowserContextClearPermissionsOptions = {};
export type BrowserContextClearPermissionsResult = void;
export type BrowserContextCloseParams = {};
export type BrowserContextCloseOptions = {};
export type BrowserContextCloseResult = void;
export type BrowserContextCookiesParams = {
  urls: string[],
};
export type BrowserContextCookiesOptions = {

};
export type BrowserContextCookiesResult = {
  cookies: types.NetworkCookie[],
};
export type BrowserContextExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingOptions = {
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingResult = void;
export type BrowserContextGrantPermissionsParams = {
  permissions: string[],
  origin?: string,
};
export type BrowserContextGrantPermissionsOptions = {
  origin?: string,
};
export type BrowserContextGrantPermissionsResult = void;
export type BrowserContextNewPageParams = {};
export type BrowserContextNewPageOptions = {};
export type BrowserContextNewPageResult = {
  page: PageChannel,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyResult = void;
export type BrowserContextSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultTimeoutNoReplyResult = void;
export type BrowserContextSetExtraHTTPHeadersParams = {
  headers: types.NameValue[],
};
export type BrowserContextSetExtraHTTPHeadersOptions = {

};
export type BrowserContextSetExtraHTTPHeadersResult = void;
export type BrowserContextSetGeolocationParams = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationOptions = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationResult = void;
export type BrowserContextSetHTTPCredentialsParams = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsOptions = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsResult = void;
export type BrowserContextSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type BrowserContextSetNetworkInterceptionEnabledOptions = {

};
export type BrowserContextSetNetworkInterceptionEnabledResult = void;
export type BrowserContextSetOfflineParams = {
  offline: boolean,
};
export type BrowserContextSetOfflineOptions = {

};
export type BrowserContextSetOfflineResult = void;
export type BrowserContextStorageStateParams = {};
export type BrowserContextStorageStateOptions = {};
export type BrowserContextStorageStateResult = {
  cookies: types.NetworkCookie[],
  origins: types.OriginStorage[],
};
export type BrowserContextPauseParams = {};
export type BrowserContextPauseOptions = {};
export type BrowserContextPauseResult = void;
export type BrowserContextRecorderSupplementEnableParams = {
  recorderParameters: types.RecorderParameters,
};
export type BrowserContextRecorderSupplementEnableOptions = {

};
export type BrowserContextRecorderSupplementEnableResult = void;
export type BrowserContextCrNewCDPSessionParams = {
  page: PageChannel,
};
export type BrowserContextCrNewCDPSessionOptions = {

};
export type BrowserContextCrNewCDPSessionResult = {
  session: CDPSessionChannel,
};

// ----------- Page -----------
export type PageInitializer = {
  mainFrame: FrameChannel,
  viewportSize?: {
    width: number,
    height: number,
  },
  isClosed: boolean,
  videoRelativePath?: string,
};
export interface PageChannel extends Channel {
  setDefaultNavigationTimeoutNoReply(progress: Progress, params: PageSetDefaultNavigationTimeoutNoReplyParams): Promise<PageSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(progress: Progress, params: PageSetDefaultTimeoutNoReplyParams): Promise<PageSetDefaultTimeoutNoReplyResult>;
  setFileChooserInterceptedNoReply(progress: Progress, params: PageSetFileChooserInterceptedNoReplyParams): Promise<PageSetFileChooserInterceptedNoReplyResult>;
  addInitScript(progress: Progress, params: PageAddInitScriptParams): Promise<PageAddInitScriptResult>;
  close(progress: Progress, params: PageCloseParams): Promise<PageCloseResult>;
  emulateMedia(progress: Progress, params: PageEmulateMediaParams): Promise<PageEmulateMediaResult>;
  exposeBinding(progress: Progress, params: PageExposeBindingParams): Promise<PageExposeBindingResult>;
  goBack(progress: Progress, params: PageGoBackParams): Promise<PageGoBackResult>;
  goForward(progress: Progress, params: PageGoForwardParams): Promise<PageGoForwardResult>;
  opener(progress: Progress, params?: PageOpenerParams): Promise<PageOpenerResult>;
  reload(progress: Progress, params: PageReloadParams): Promise<PageReloadResult>;
  screenshot(progress: Progress, params: PageScreenshotParams): Promise<PageScreenshotResult>;
  setExtraHTTPHeaders(progress: Progress, params: PageSetExtraHTTPHeadersParams): Promise<PageSetExtraHTTPHeadersResult>;
  setNetworkInterceptionEnabled(progress: Progress, params: PageSetNetworkInterceptionEnabledParams): Promise<PageSetNetworkInterceptionEnabledResult>;
  setViewportSize(progress: Progress, params: PageSetViewportSizeParams): Promise<PageSetViewportSizeResult>;
  keyboardDown(progress: Progress, params: PageKeyboardDownParams): Promise<PageKeyboardDownResult>;
  keyboardUp(progress: Progress, params: PageKeyboardUpParams): Promise<PageKeyboardUpResult>;
  keyboardInsertText(progress: Progress, params: PageKeyboardInsertTextParams): Promise<PageKeyboardInsertTextResult>;
  keyboardType(progress: Progress, params: PageKeyboardTypeParams): Promise<PageKeyboardTypeResult>;
  keyboardPress(progress: Progress, params: PageKeyboardPressParams): Promise<PageKeyboardPressResult>;
  mouseMove(progress: Progress, params: PageMouseMoveParams): Promise<PageMouseMoveResult>;
  mouseDown(progress: Progress, params: PageMouseDownParams): Promise<PageMouseDownResult>;
  mouseUp(progress: Progress, params: PageMouseUpParams): Promise<PageMouseUpResult>;
  mouseClick(progress: Progress, params: PageMouseClickParams): Promise<PageMouseClickResult>;
  touchscreenTap(progress: Progress, params: PageTouchscreenTapParams): Promise<PageTouchscreenTapResult>;
  accessibilitySnapshot(progress: Progress, params: PageAccessibilitySnapshotParams): Promise<PageAccessibilitySnapshotResult>;
  pdf(progress: Progress, params: PagePdfParams): Promise<PagePdfResult>;
  crStartJSCoverage(progress: Progress, params: PageCrStartJSCoverageParams): Promise<PageCrStartJSCoverageResult>;
  crStopJSCoverage(progress: Progress, params?: PageCrStopJSCoverageParams): Promise<PageCrStopJSCoverageResult>;
  crStartCSSCoverage(progress: Progress, params: PageCrStartCSSCoverageParams): Promise<PageCrStartCSSCoverageResult>;
  crStopCSSCoverage(progress: Progress, params?: PageCrStopCSSCoverageParams): Promise<PageCrStopCSSCoverageResult>;
  bringToFront(progress: Progress, params?: PageBringToFrontParams): Promise<PageBringToFrontResult>;
}
export type PageBindingCallEvent = {
  binding: BindingCallChannel,
};
export type PageCloseEvent = {};
export type PageConsoleEvent = {
  message: ConsoleMessageChannel,
};
export type PageCrashEvent = {};
export type PageDialogEvent = {
  dialog: DialogChannel,
};
export type PageDownloadEvent = {
  download: DownloadChannel,
};
export type PageDomcontentloadedEvent = {};
export type PageFileChooserEvent = {
  element: ElementHandleChannel,
  isMultiple: boolean,
};
export type PageFrameAttachedEvent = {
  frame: FrameChannel,
};
export type PageFrameDetachedEvent = {
  frame: FrameChannel,
};
export type PageLoadEvent = {};
export type PagePageErrorEvent = {
  error: types.SerializedError,
};
export type PagePopupEvent = {
  page: PageChannel,
};
export type PageRequestEvent = {
  request: RequestChannel,
};
export type PageRequestFailedEvent = {
  request: RequestChannel,
  failureText?: string,
  responseEndTiming: number,
};
export type PageRequestFinishedEvent = {
  request: RequestChannel,
  responseEndTiming: number,
};
export type PageResponseEvent = {
  response: ResponseChannel,
};
export type PageRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type PageVideoEvent = {
  relativePath: string,
};
export type PageWebSocketEvent = {
  webSocket: WebSocketChannel,
};
export type PageWorkerEvent = {
  worker: WorkerChannel,
};
export type PageSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type PageSetDefaultNavigationTimeoutNoReplyResult = void;
export type PageSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultTimeoutNoReplyOptions = {

};
export type PageSetDefaultTimeoutNoReplyResult = void;
export type PageSetFileChooserInterceptedNoReplyParams = {
  intercepted: boolean,
};
export type PageSetFileChooserInterceptedNoReplyOptions = {

};
export type PageSetFileChooserInterceptedNoReplyResult = void;
export type PageAddInitScriptParams = {
  source: string,
};
export type PageAddInitScriptOptions = {

};
export type PageAddInitScriptResult = void;
export type PageCloseParams = {
  runBeforeUnload?: boolean,
};
export type PageCloseOptions = {
  runBeforeUnload?: boolean,
};
export type PageCloseResult = void;
export type PageEmulateMediaParams = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaOptions = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaResult = void;
export type PageExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type PageExposeBindingOptions = {
  needsHandle?: boolean,
};
export type PageExposeBindingResult = void;
export type PageGoBackParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackResult = {
  response?: ResponseChannel,
};
export type PageGoForwardParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardResult = {
  response?: ResponseChannel,
};
export type PageOpenerParams = {};
export type PageOpenerOptions = {};
export type PageOpenerResult = {
  page?: PageChannel,
};
export type PageReloadParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadResult = {
  response?: ResponseChannel,
};
export type PageScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: types.Rect,
};
export type PageScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: types.Rect,
};
export type PageScreenshotResult = {
  binary: types.Binary,
};
export type PageSetExtraHTTPHeadersParams = {
  headers: types.NameValue[],
};
export type PageSetExtraHTTPHeadersOptions = {

};
export type PageSetExtraHTTPHeadersResult = void;
export type PageSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type PageSetNetworkInterceptionEnabledOptions = {

};
export type PageSetNetworkInterceptionEnabledResult = void;
export type PageSetViewportSizeParams = {
  viewportSize: {
    width: number,
    height: number,
  },
};
export type PageSetViewportSizeOptions = {

};
export type PageSetViewportSizeResult = void;
export type PageKeyboardDownParams = {
  key: string,
};
export type PageKeyboardDownOptions = {

};
export type PageKeyboardDownResult = void;
export type PageKeyboardUpParams = {
  key: string,
};
export type PageKeyboardUpOptions = {

};
export type PageKeyboardUpResult = void;
export type PageKeyboardInsertTextParams = {
  text: string,
};
export type PageKeyboardInsertTextOptions = {

};
export type PageKeyboardInsertTextResult = void;
export type PageKeyboardTypeParams = {
  text: string,
  delay?: number,
};
export type PageKeyboardTypeOptions = {
  delay?: number,
};
export type PageKeyboardTypeResult = void;
export type PageKeyboardPressParams = {
  key: string,
  delay?: number,
};
export type PageKeyboardPressOptions = {
  delay?: number,
};
export type PageKeyboardPressResult = void;
export type PageMouseMoveParams = {
  x: number,
  y: number,
  steps?: number,
};
export type PageMouseMoveOptions = {
  steps?: number,
};
export type PageMouseMoveResult = void;
export type PageMouseDownParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownResult = void;
export type PageMouseUpParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpResult = void;
export type PageMouseClickParams = {
  x: number,
  y: number,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickOptions = {
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickResult = void;
export type PageTouchscreenTapParams = {
  x: number,
  y: number,
};
export type PageTouchscreenTapOptions = {

};
export type PageTouchscreenTapResult = void;
export type PageAccessibilitySnapshotParams = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotOptions = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotResult = {
  rootAXNode?: types.AXNode,
};
export type PagePdfParams = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfOptions = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfResult = {
  pdf: types.Binary,
};
export type PageCrStartJSCoverageParams = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageOptions = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageResult = void;
export type PageCrStopJSCoverageParams = {};
export type PageCrStopJSCoverageOptions = {};
export type PageCrStopJSCoverageResult = {
  entries: {
    url: string,
    scriptId: string,
    source?: string,
    functions: {
      functionName: string,
      isBlockCoverage: boolean,
      ranges: {
        startOffset: number,
        endOffset: number,
        count: number,
      }[],
    }[],
  }[],
};
export type PageCrStartCSSCoverageParams = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageOptions = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageResult = void;
export type PageCrStopCSSCoverageParams = {};
export type PageCrStopCSSCoverageOptions = {};
export type PageCrStopCSSCoverageResult = {
  entries: {
    url: string,
    text?: string,
    ranges: {
      start: number,
      end: number,
    }[],
  }[],
};
export type PageBringToFrontParams = {};
export type PageBringToFrontOptions = {};
export type PageBringToFrontResult = void;

// ----------- Frame -----------
export type FrameInitializer = {
  url: string,
  name: string,
  parentFrame?: FrameChannel,
  loadStates: ('load' | 'domcontentloaded' | 'networkidle')[],
};
export interface FrameChannel extends Channel {
  evalOnSelector(progress: Progress, params: FrameEvalOnSelectorParams): Promise<FrameEvalOnSelectorResult>;
  evalOnSelectorAll(progress: Progress, params: FrameEvalOnSelectorAllParams): Promise<FrameEvalOnSelectorAllResult>;
  addScriptTag(progress: Progress, params: FrameAddScriptTagParams): Promise<FrameAddScriptTagResult>;
  addStyleTag(progress: Progress, params: FrameAddStyleTagParams): Promise<FrameAddStyleTagResult>;
  check(progress: Progress, params: FrameCheckParams): Promise<FrameCheckResult>;
  click(progress: Progress, params: FrameClickParams): Promise<FrameClickResult>;
  content(progress: Progress, params?: FrameContentParams): Promise<FrameContentResult>;
  dblclick(progress: Progress, params: FrameDblclickParams): Promise<FrameDblclickResult>;
  dispatchEvent(progress: Progress, params: FrameDispatchEventParams): Promise<FrameDispatchEventResult>;
  evaluateExpression(progress: Progress, params: FrameEvaluateExpressionParams): Promise<FrameEvaluateExpressionResult>;
  evaluateExpressionHandle(progress: Progress, params: FrameEvaluateExpressionHandleParams): Promise<FrameEvaluateExpressionHandleResult>;
  fill(progress: Progress, params: FrameFillParams): Promise<FrameFillResult>;
  focus(progress: Progress, params: FrameFocusParams): Promise<FrameFocusResult>;
  frameElement(progress: Progress, params?: FrameFrameElementParams): Promise<FrameFrameElementResult>;
  getAttribute(progress: Progress, params: FrameGetAttributeParams): Promise<FrameGetAttributeResult>;
  goto(progress: Progress, params: FrameGotoParams): Promise<FrameGotoResult>;
  hover(progress: Progress, params: FrameHoverParams): Promise<FrameHoverResult>;
  innerHTML(progress: Progress, params: FrameInnerHTMLParams): Promise<FrameInnerHTMLResult>;
  innerText(progress: Progress, params: FrameInnerTextParams): Promise<FrameInnerTextResult>;
  isChecked(progress: Progress, params: FrameIsCheckedParams): Promise<FrameIsCheckedResult>;
  isDisabled(progress: Progress, params: FrameIsDisabledParams): Promise<FrameIsDisabledResult>;
  isEnabled(progress: Progress, params: FrameIsEnabledParams): Promise<FrameIsEnabledResult>;
  isHidden(progress: Progress, params: FrameIsHiddenParams): Promise<FrameIsHiddenResult>;
  isVisible(progress: Progress, params: FrameIsVisibleParams): Promise<FrameIsVisibleResult>;
  isEditable(progress: Progress, params: FrameIsEditableParams): Promise<FrameIsEditableResult>;
  press(progress: Progress, params: FramePressParams): Promise<FramePressResult>;
  querySelector(progress: Progress, params: FrameQuerySelectorParams): Promise<FrameQuerySelectorResult>;
  querySelectorAll(progress: Progress, params: FrameQuerySelectorAllParams): Promise<FrameQuerySelectorAllResult>;
  selectOption(progress: Progress, params: FrameSelectOptionParams): Promise<FrameSelectOptionResult>;
  setContent(progress: Progress, params: FrameSetContentParams): Promise<FrameSetContentResult>;
  setInputFiles(progress: Progress, params: FrameSetInputFilesParams): Promise<FrameSetInputFilesResult>;
  tap(progress: Progress, params: FrameTapParams): Promise<FrameTapResult>;
  textContent(progress: Progress, params: FrameTextContentParams): Promise<FrameTextContentResult>;
  title(progress: Progress, params?: FrameTitleParams): Promise<FrameTitleResult>;
  type(progress: Progress, params: FrameTypeParams): Promise<FrameTypeResult>;
  uncheck(progress: Progress, params: FrameUncheckParams): Promise<FrameUncheckResult>;
  waitForFunction(progress: Progress, params: FrameWaitForFunctionParams): Promise<FrameWaitForFunctionResult>;
  waitForSelector(progress: Progress, params: FrameWaitForSelectorParams): Promise<FrameWaitForSelectorResult>;
}
export type FrameLoadstateEvent = {
  add?: 'load' | 'domcontentloaded' | 'networkidle',
  remove?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameNavigatedEvent = {
  url: string,
  name: string,
  newDocument?: {
    request?: RequestChannel,
  },
  error?: string,
};
export type FrameEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type FrameEvalOnSelectorOptions = {
  isFunction?: boolean,
};
export type FrameEvalOnSelectorResult = {
  value: types.SerializedValue,
};
export type FrameEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type FrameEvalOnSelectorAllOptions = {
  isFunction?: boolean,
};
export type FrameEvalOnSelectorAllResult = {
  value: types.SerializedValue,
};
export type FrameAddScriptTagParams = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagOptions = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagResult = {
  element: ElementHandleChannel,
};
export type FrameAddStyleTagParams = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagOptions = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagResult = {
  element: ElementHandleChannel,
};
export type FrameCheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckResult = void;
export type FrameClickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickResult = void;
export type FrameContentParams = {};
export type FrameContentOptions = {};
export type FrameContentResult = {
  value: string,
};
export type FrameDblclickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickResult = void;
export type FrameDispatchEventParams = {
  selector: string,
  type: string,
  eventInit: types.SerializedArgument,
  timeout?: number,
};
export type FrameDispatchEventOptions = {
  timeout?: number,
};
export type FrameDispatchEventResult = void;
export type FrameEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionOptions = {
  isFunction?: boolean,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type FrameEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type FrameFillParams = {
  selector: string,
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillResult = void;
export type FrameFocusParams = {
  selector: string,
  timeout?: number,
};
export type FrameFocusOptions = {
  timeout?: number,
};
export type FrameFocusResult = void;
export type FrameFrameElementParams = {};
export type FrameFrameElementOptions = {};
export type FrameFrameElementResult = {
  element: ElementHandleChannel,
};
export type FrameGetAttributeParams = {
  selector: string,
  name: string,
  timeout?: number,
};
export type FrameGetAttributeOptions = {
  timeout?: number,
};
export type FrameGetAttributeResult = {
  value?: string,
};
export type FrameGotoParams = {
  url: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoResult = {
  response?: ResponseChannel,
};
export type FrameHoverParams = {
  selector: string,
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameHoverResult = void;
export type FrameInnerHTMLParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerHTMLOptions = {
  timeout?: number,
};
export type FrameInnerHTMLResult = {
  value: string,
};
export type FrameInnerTextParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerTextOptions = {
  timeout?: number,
};
export type FrameInnerTextResult = {
  value: string,
};
export type FrameIsCheckedParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsCheckedOptions = {
  timeout?: number,
};
export type FrameIsCheckedResult = {
  value: boolean,
};
export type FrameIsDisabledParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsDisabledOptions = {
  timeout?: number,
};
export type FrameIsDisabledResult = {
  value: boolean,
};
export type FrameIsEnabledParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsEnabledOptions = {
  timeout?: number,
};
export type FrameIsEnabledResult = {
  value: boolean,
};
export type FrameIsHiddenParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsHiddenOptions = {
  timeout?: number,
};
export type FrameIsHiddenResult = {
  value: boolean,
};
export type FrameIsVisibleParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsVisibleOptions = {
  timeout?: number,
};
export type FrameIsVisibleResult = {
  value: boolean,
};
export type FrameIsEditableParams = {
  selector: string,
  timeout?: number,
};
export type FrameIsEditableOptions = {
  timeout?: number,
};
export type FrameIsEditableResult = {
  value: boolean,
};
export type FramePressParams = {
  selector: string,
  key: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressResult = void;
export type FrameQuerySelectorParams = {
  selector: string,
};
export type FrameQuerySelectorOptions = {

};
export type FrameQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type FrameQuerySelectorAllParams = {
  selector: string,
};
export type FrameQuerySelectorAllOptions = {

};
export type FrameQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type FrameSelectOptionParams = {
  selector: string,
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionResult = {
  values: string[],
};
export type FrameSetContentParams = {
  html: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentResult = void;
export type FrameSetInputFilesParams = {
  selector: string,
  files: {
    name: string,
    mimeType: string,
    buffer: types.Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesResult = void;
export type FrameTapParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type FrameTapResult = void;
export type FrameTextContentParams = {
  selector: string,
  timeout?: number,
};
export type FrameTextContentOptions = {
  timeout?: number,
};
export type FrameTextContentResult = {
  value?: string,
};
export type FrameTitleParams = {};
export type FrameTitleOptions = {};
export type FrameTitleResult = {
  value: string,
};
export type FrameTypeParams = {
  selector: string,
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeResult = void;
export type FrameUncheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckResult = void;
export type FrameWaitForFunctionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionOptions = {
  isFunction?: boolean,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionResult = {
  handle: JSHandleChannel,
};
export type FrameWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Worker -----------
export type WorkerInitializer = {
  url: string,
};
export interface WorkerChannel extends Channel {
  evaluateExpression(progress: Progress, params: WorkerEvaluateExpressionParams): Promise<WorkerEvaluateExpressionResult>;
  evaluateExpressionHandle(progress: Progress, params: WorkerEvaluateExpressionHandleParams): Promise<WorkerEvaluateExpressionHandleResult>;
}
export type WorkerCloseEvent = {};
export type WorkerEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type WorkerEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type WorkerEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type WorkerEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type WorkerEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type WorkerEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};

// ----------- JSHandle -----------
export type JSHandleInitializer = {
  preview: string,
};
export interface JSHandleChannel extends Channel {
  dispose(progress: Progress, params?: JSHandleDisposeParams): Promise<JSHandleDisposeResult>;
  evaluateExpression(progress: Progress, params: JSHandleEvaluateExpressionParams): Promise<JSHandleEvaluateExpressionResult>;
  evaluateExpressionHandle(progress: Progress, params: JSHandleEvaluateExpressionHandleParams): Promise<JSHandleEvaluateExpressionHandleResult>;
  getPropertyList(progress: Progress, params?: JSHandleGetPropertyListParams): Promise<JSHandleGetPropertyListResult>;
  getProperty(progress: Progress, params: JSHandleGetPropertyParams): Promise<JSHandleGetPropertyResult>;
  jsonValue(progress: Progress, params?: JSHandleJsonValueParams): Promise<JSHandleJsonValueResult>;
}
export type JSHandlePreviewUpdatedEvent = {
  preview: string,
};
export type JSHandleDisposeParams = {};
export type JSHandleDisposeOptions = {};
export type JSHandleDisposeResult = void;
export type JSHandleEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type JSHandleEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type JSHandleEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type JSHandleEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type JSHandleEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type JSHandleEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type JSHandleGetPropertyListParams = {};
export type JSHandleGetPropertyListOptions = {};
export type JSHandleGetPropertyListResult = {
  properties: {
    name: string,
    value: JSHandleChannel,
  }[],
};
export type JSHandleGetPropertyParams = {
  name: string,
};
export type JSHandleGetPropertyOptions = {

};
export type JSHandleGetPropertyResult = {
  handle: JSHandleChannel,
};
export type JSHandleJsonValueParams = {};
export type JSHandleJsonValueOptions = {};
export type JSHandleJsonValueResult = {
  value: types.SerializedValue,
};

// ----------- ElementHandle -----------
export type ElementHandleInitializer = {};
export interface ElementHandleChannel extends JSHandleChannel {
  evalOnSelector(progress: Progress, params: ElementHandleEvalOnSelectorParams): Promise<ElementHandleEvalOnSelectorResult>;
  evalOnSelectorAll(progress: Progress, params: ElementHandleEvalOnSelectorAllParams): Promise<ElementHandleEvalOnSelectorAllResult>;
  boundingBox(progress: Progress, params?: ElementHandleBoundingBoxParams): Promise<ElementHandleBoundingBoxResult>;
  check(progress: Progress, params: ElementHandleCheckParams): Promise<ElementHandleCheckResult>;
  click(progress: Progress, params: ElementHandleClickParams): Promise<ElementHandleClickResult>;
  contentFrame(progress: Progress, params?: ElementHandleContentFrameParams): Promise<ElementHandleContentFrameResult>;
  dblclick(progress: Progress, params: ElementHandleDblclickParams): Promise<ElementHandleDblclickResult>;
  dispatchEvent(progress: Progress, params: ElementHandleDispatchEventParams): Promise<ElementHandleDispatchEventResult>;
  fill(progress: Progress, params: ElementHandleFillParams): Promise<ElementHandleFillResult>;
  focus(progress: Progress, params?: ElementHandleFocusParams): Promise<ElementHandleFocusResult>;
  getAttribute(progress: Progress, params: ElementHandleGetAttributeParams): Promise<ElementHandleGetAttributeResult>;
  hover(progress: Progress, params: ElementHandleHoverParams): Promise<ElementHandleHoverResult>;
  innerHTML(progress: Progress, params?: ElementHandleInnerHTMLParams): Promise<ElementHandleInnerHTMLResult>;
  innerText(progress: Progress, params?: ElementHandleInnerTextParams): Promise<ElementHandleInnerTextResult>;
  isChecked(progress: Progress, params?: ElementHandleIsCheckedParams): Promise<ElementHandleIsCheckedResult>;
  isDisabled(progress: Progress, params?: ElementHandleIsDisabledParams): Promise<ElementHandleIsDisabledResult>;
  isEditable(progress: Progress, params?: ElementHandleIsEditableParams): Promise<ElementHandleIsEditableResult>;
  isEnabled(progress: Progress, params?: ElementHandleIsEnabledParams): Promise<ElementHandleIsEnabledResult>;
  isHidden(progress: Progress, params?: ElementHandleIsHiddenParams): Promise<ElementHandleIsHiddenResult>;
  isVisible(progress: Progress, params?: ElementHandleIsVisibleParams): Promise<ElementHandleIsVisibleResult>;
  ownerFrame(progress: Progress, params?: ElementHandleOwnerFrameParams): Promise<ElementHandleOwnerFrameResult>;
  press(progress: Progress, params: ElementHandlePressParams): Promise<ElementHandlePressResult>;
  querySelector(progress: Progress, params: ElementHandleQuerySelectorParams): Promise<ElementHandleQuerySelectorResult>;
  querySelectorAll(progress: Progress, params: ElementHandleQuerySelectorAllParams): Promise<ElementHandleQuerySelectorAllResult>;
  screenshot(progress: Progress, params: ElementHandleScreenshotParams): Promise<ElementHandleScreenshotResult>;
  scrollIntoViewIfNeeded(progress: Progress, params: ElementHandleScrollIntoViewIfNeededParams): Promise<ElementHandleScrollIntoViewIfNeededResult>;
  selectOption(progress: Progress, params: ElementHandleSelectOptionParams): Promise<ElementHandleSelectOptionResult>;
  selectText(progress: Progress, params: ElementHandleSelectTextParams): Promise<ElementHandleSelectTextResult>;
  setInputFiles(progress: Progress, params: ElementHandleSetInputFilesParams): Promise<ElementHandleSetInputFilesResult>;
  tap(progress: Progress, params: ElementHandleTapParams): Promise<ElementHandleTapResult>;
  textContent(progress: Progress, params?: ElementHandleTextContentParams): Promise<ElementHandleTextContentResult>;
  type(progress: Progress, params: ElementHandleTypeParams): Promise<ElementHandleTypeResult>;
  uncheck(progress: Progress, params: ElementHandleUncheckParams): Promise<ElementHandleUncheckResult>;
  waitForElementState(progress: Progress, params: ElementHandleWaitForElementStateParams): Promise<ElementHandleWaitForElementStateResult>;
  waitForSelector(progress: Progress, params: ElementHandleWaitForSelectorParams): Promise<ElementHandleWaitForSelectorResult>;
}
export type ElementHandleEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElementHandleEvalOnSelectorOptions = {
  isFunction?: boolean,
};
export type ElementHandleEvalOnSelectorResult = {
  value: types.SerializedValue,
};
export type ElementHandleEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElementHandleEvalOnSelectorAllOptions = {
  isFunction?: boolean,
};
export type ElementHandleEvalOnSelectorAllResult = {
  value: types.SerializedValue,
};
export type ElementHandleBoundingBoxParams = {};
export type ElementHandleBoundingBoxOptions = {};
export type ElementHandleBoundingBoxResult = {
  value?: types.Rect,
};
export type ElementHandleCheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckResult = void;
export type ElementHandleClickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickResult = void;
export type ElementHandleContentFrameParams = {};
export type ElementHandleContentFrameOptions = {};
export type ElementHandleContentFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandleDblclickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickResult = void;
export type ElementHandleDispatchEventParams = {
  type: string,
  eventInit: types.SerializedArgument,
};
export type ElementHandleDispatchEventOptions = {

};
export type ElementHandleDispatchEventResult = void;
export type ElementHandleFillParams = {
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillResult = void;
export type ElementHandleFocusParams = {};
export type ElementHandleFocusOptions = {};
export type ElementHandleFocusResult = void;
export type ElementHandleGetAttributeParams = {
  name: string,
};
export type ElementHandleGetAttributeOptions = {

};
export type ElementHandleGetAttributeResult = {
  value?: string,
};
export type ElementHandleHoverParams = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleHoverResult = void;
export type ElementHandleInnerHTMLParams = {};
export type ElementHandleInnerHTMLOptions = {};
export type ElementHandleInnerHTMLResult = {
  value: string,
};
export type ElementHandleInnerTextParams = {};
export type ElementHandleInnerTextOptions = {};
export type ElementHandleInnerTextResult = {
  value: string,
};
export type ElementHandleIsCheckedParams = {};
export type ElementHandleIsCheckedOptions = {};
export type ElementHandleIsCheckedResult = {
  value: boolean,
};
export type ElementHandleIsDisabledParams = {};
export type ElementHandleIsDisabledOptions = {};
export type ElementHandleIsDisabledResult = {
  value: boolean,
};
export type ElementHandleIsEditableParams = {};
export type ElementHandleIsEditableOptions = {};
export type ElementHandleIsEditableResult = {
  value: boolean,
};
export type ElementHandleIsEnabledParams = {};
export type ElementHandleIsEnabledOptions = {};
export type ElementHandleIsEnabledResult = {
  value: boolean,
};
export type ElementHandleIsHiddenParams = {};
export type ElementHandleIsHiddenOptions = {};
export type ElementHandleIsHiddenResult = {
  value: boolean,
};
export type ElementHandleIsVisibleParams = {};
export type ElementHandleIsVisibleOptions = {};
export type ElementHandleIsVisibleResult = {
  value: boolean,
};
export type ElementHandleOwnerFrameParams = {};
export type ElementHandleOwnerFrameOptions = {};
export type ElementHandleOwnerFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandlePressParams = {
  key: string,
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressOptions = {
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressResult = void;
export type ElementHandleQuerySelectorParams = {
  selector: string,
};
export type ElementHandleQuerySelectorOptions = {

};
export type ElementHandleQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type ElementHandleQuerySelectorAllParams = {
  selector: string,
};
export type ElementHandleQuerySelectorAllOptions = {

};
export type ElementHandleQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type ElementHandleScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotResult = {
  binary: types.Binary,
};
export type ElementHandleScrollIntoViewIfNeededParams = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededOptions = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededResult = void;
export type ElementHandleSelectOptionParams = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionResult = {
  values: string[],
};
export type ElementHandleSelectTextParams = {
  timeout?: number,
};
export type ElementHandleSelectTextOptions = {
  timeout?: number,
};
export type ElementHandleSelectTextResult = void;
export type ElementHandleSetInputFilesParams = {
  files: {
    name: string,
    mimeType: string,
    buffer: types.Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesResult = void;
export type ElementHandleTapParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: types.Point,
  timeout?: number,
};
export type ElementHandleTapResult = void;
export type ElementHandleTextContentParams = {};
export type ElementHandleTextContentOptions = {};
export type ElementHandleTextContentResult = {
  value?: string,
};
export type ElementHandleTypeParams = {
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeResult = void;
export type ElementHandleUncheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckResult = void;
export type ElementHandleWaitForElementStateParams = {
  state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled' | 'editable',
  timeout?: number,
};
export type ElementHandleWaitForElementStateOptions = {
  timeout?: number,
};
export type ElementHandleWaitForElementStateResult = void;
export type ElementHandleWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Request -----------
export type RequestInitializer = {
  frame: FrameChannel,
  url: string,
  resourceType: string,
  method: string,
  postData?: types.Binary,
  headers: {
    name: string,
    value: string,
  }[],
  isNavigationRequest: boolean,
  redirectedFrom?: RequestChannel,
};
export interface RequestChannel extends Channel {
  response(progress: Progress, params?: RequestResponseParams): Promise<RequestResponseResult>;
}
export type RequestResponseParams = {};
export type RequestResponseOptions = {};
export type RequestResponseResult = {
  response?: ResponseChannel,
};

// ----------- Route -----------
export type RouteInitializer = {
  request: RequestChannel,
};
export interface RouteChannel extends Channel {
  abort(progress: Progress, params: RouteAbortParams): Promise<RouteAbortResult>;
  continue(progress: Progress, params: RouteContinueParams): Promise<RouteContinueResult>;
  fulfill(progress: Progress, params: RouteFulfillParams): Promise<RouteFulfillResult>;
}
export type RouteAbortParams = {
  errorCode?: string,
};
export type RouteAbortOptions = {
  errorCode?: string,
};
export type RouteAbortResult = void;
export type RouteContinueParams = {
  url?: string,
  method?: string,
  headers?: types.NameValue[],
  postData?: types.Binary,
};
export type RouteContinueOptions = {
  url?: string,
  method?: string,
  headers?: types.NameValue[],
  postData?: types.Binary,
};
export type RouteContinueResult = void;
export type RouteFulfillParams = {
  status?: number,
  headers?: types.NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillOptions = {
  status?: number,
  headers?: types.NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillResult = void;

// ----------- Response -----------
export type ResponseInitializer = {
  request: RequestChannel,
  url: string,
  status: number,
  statusText: string,
  requestHeaders: {
    name: string,
    value: string,
  }[],
  headers: {
    name: string,
    value: string,
  }[],
  timing: types.ResourceTiming,
};
export interface ResponseChannel extends Channel {
  body(progress: Progress, params?: ResponseBodyParams): Promise<ResponseBodyResult>;
  finished(progress: Progress, params?: ResponseFinishedParams): Promise<ResponseFinishedResult>;
}
export type ResponseBodyParams = {};
export type ResponseBodyOptions = {};
export type ResponseBodyResult = {
  binary: types.Binary,
};
export type ResponseFinishedParams = {};
export type ResponseFinishedOptions = {};
export type ResponseFinishedResult = {
  error?: string,
};

// ----------- WebSocket -----------
export type WebSocketInitializer = {
  url: string,
};
export interface WebSocketChannel extends Channel {
}
export type WebSocketOpenEvent = {};
export type WebSocketFrameSentEvent = {
  opcode: number,
  data: string,
};
export type WebSocketFrameReceivedEvent = {
  opcode: number,
  data: string,
};
export type WebSocketSocketErrorEvent = {
  error: string,
};
export type WebSocketCloseEvent = {};

// ----------- ConsoleMessage -----------
export type ConsoleMessageInitializer = {
  type: string,
  text: string,
  args: JSHandleChannel[],
  location: {
    url: string,
    lineNumber: number,
    columnNumber: number,
  },
};
export interface ConsoleMessageChannel extends Channel {
}

// ----------- BindingCall -----------
export type BindingCallInitializer = {
  frame: FrameChannel,
  name: string,
  args?: types.SerializedValue[],
  handle?: JSHandleChannel,
};
export interface BindingCallChannel extends Channel {
  reject(progress: Progress, params: BindingCallRejectParams): Promise<BindingCallRejectResult>;
  resolve(progress: Progress, params: BindingCallResolveParams): Promise<BindingCallResolveResult>;
}
export type BindingCallRejectParams = {
  error: types.SerializedError,
};
export type BindingCallRejectOptions = {

};
export type BindingCallRejectResult = void;
export type BindingCallResolveParams = {
  result: types.SerializedArgument,
};
export type BindingCallResolveOptions = {

};
export type BindingCallResolveResult = void;

// ----------- Dialog -----------
export type DialogInitializer = {
  type: string,
  message: string,
  defaultValue: string,
};
export interface DialogChannel extends Channel {
  accept(progress: Progress, params: DialogAcceptParams): Promise<DialogAcceptResult>;
  dismiss(progress: Progress, params?: DialogDismissParams): Promise<DialogDismissResult>;
}
export type DialogAcceptParams = {
  promptText?: string,
};
export type DialogAcceptOptions = {
  promptText?: string,
};
export type DialogAcceptResult = void;
export type DialogDismissParams = {};
export type DialogDismissOptions = {};
export type DialogDismissResult = void;

// ----------- Download -----------
export type DownloadInitializer = {
  url: string,
  suggestedFilename: string,
};
export interface DownloadChannel extends Channel {
  path(progress: Progress, params?: DownloadPathParams): Promise<DownloadPathResult>;
  saveAs(progress: Progress, params: DownloadSaveAsParams): Promise<DownloadSaveAsResult>;
  saveAsStream(progress: Progress, params?: DownloadSaveAsStreamParams): Promise<DownloadSaveAsStreamResult>;
  failure(progress: Progress, params?: DownloadFailureParams): Promise<DownloadFailureResult>;
  stream(progress: Progress, params?: DownloadStreamParams): Promise<DownloadStreamResult>;
  delete(progress: Progress, params?: DownloadDeleteParams): Promise<DownloadDeleteResult>;
}
export type DownloadPathParams = {};
export type DownloadPathOptions = {};
export type DownloadPathResult = {
  value?: string,
};
export type DownloadSaveAsParams = {
  path: string,
};
export type DownloadSaveAsOptions = {

};
export type DownloadSaveAsResult = void;
export type DownloadSaveAsStreamParams = {};
export type DownloadSaveAsStreamOptions = {};
export type DownloadSaveAsStreamResult = {
  stream: StreamChannel,
};
export type DownloadFailureParams = {};
export type DownloadFailureOptions = {};
export type DownloadFailureResult = {
  error?: string,
};
export type DownloadStreamParams = {};
export type DownloadStreamOptions = {};
export type DownloadStreamResult = {
  stream?: StreamChannel,
};
export type DownloadDeleteParams = {};
export type DownloadDeleteOptions = {};
export type DownloadDeleteResult = void;

// ----------- Stream -----------
export type StreamInitializer = {};
export interface StreamChannel extends Channel {
  read(progress: Progress, params: StreamReadParams): Promise<StreamReadResult>;
  close(progress: Progress, params?: StreamCloseParams): Promise<StreamCloseResult>;
}
export type StreamReadParams = {
  size?: number,
};
export type StreamReadOptions = {
  size?: number,
};
export type StreamReadResult = {
  binary: types.Binary,
};
export type StreamCloseParams = {};
export type StreamCloseOptions = {};
export type StreamCloseResult = void;

// ----------- CDPSession -----------
export type CDPSessionInitializer = {};
export interface CDPSessionChannel extends Channel {
  send(progress: Progress, params: CDPSessionSendParams): Promise<CDPSessionSendResult>;
  detach(progress: Progress, params?: CDPSessionDetachParams): Promise<CDPSessionDetachResult>;
}
export type CDPSessionEventEvent = {
  method: string,
  params?: any,
};
export type CDPSessionSendParams = {
  method: string,
  params?: any,
};
export type CDPSessionSendOptions = {
  params?: any,
};
export type CDPSessionSendResult = {
  result: any,
};
export type CDPSessionDetachParams = {};
export type CDPSessionDetachOptions = {};
export type CDPSessionDetachResult = void;

// ----------- Electron -----------
export type ElectronInitializer = {};
export interface ElectronChannel extends Channel {
  launch(progress: Progress, params: ElectronLaunchParams): Promise<ElectronLaunchResult>;
}
export type ElectronLaunchParams = {
  sdkLanguage: string,
  executablePath?: string,
  args?: string[],
  cwd?: string,
  env?: types.NameValue[],
  timeout?: number,
};
export type ElectronLaunchOptions = {
  executablePath?: string,
  args?: string[],
  cwd?: string,
  env?: types.NameValue[],
  timeout?: number,
};
export type ElectronLaunchResult = {
  electronApplication: ElectronApplicationChannel,
};

// ----------- ElectronApplication -----------
export type ElectronApplicationInitializer = {};
export interface ElectronApplicationChannel extends Channel {
  evaluateExpression(progress: Progress, params: ElectronApplicationEvaluateExpressionParams): Promise<ElectronApplicationEvaluateExpressionResult>;
  evaluateExpressionHandle(progress: Progress, params: ElectronApplicationEvaluateExpressionHandleParams): Promise<ElectronApplicationEvaluateExpressionHandleResult>;
  close(progress: Progress, params?: ElectronApplicationCloseParams): Promise<ElectronApplicationCloseResult>;
}
export type ElectronApplicationContextEvent = {
  context: BrowserContextChannel,
};
export type ElectronApplicationCloseEvent = {};
export type ElectronApplicationWindowEvent = {
  page: PageChannel,
  browserWindow: JSHandleChannel,
};
export type ElectronApplicationEvaluateExpressionParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionOptions = {
  isFunction?: boolean,
};
export type ElectronApplicationEvaluateExpressionResult = {
  value: types.SerializedValue,
};
export type ElectronApplicationEvaluateExpressionHandleParams = {
  expression: string,
  isFunction?: boolean,
  arg: types.SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionHandleOptions = {
  isFunction?: boolean,
};
export type ElectronApplicationEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type ElectronApplicationCloseParams = {};
export type ElectronApplicationCloseOptions = {};
export type ElectronApplicationCloseResult = void;

// ----------- Android -----------
export type AndroidInitializer = {};
export interface AndroidChannel extends Channel {
  devices(progress: Progress, params?: AndroidDevicesParams): Promise<AndroidDevicesResult>;
  setDefaultTimeoutNoReply(progress: Progress, params: AndroidSetDefaultTimeoutNoReplyParams): Promise<AndroidSetDefaultTimeoutNoReplyResult>;
}
export type AndroidDevicesParams = {};
export type AndroidDevicesOptions = {};
export type AndroidDevicesResult = {
  devices: AndroidDeviceChannel[],
};
export type AndroidSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidSetDefaultTimeoutNoReplyResult = void;

// ----------- AndroidSocket -----------
export type AndroidSocketInitializer = {};
export interface AndroidSocketChannel extends Channel {
  write(progress: Progress, params: AndroidSocketWriteParams): Promise<AndroidSocketWriteResult>;
  close(progress: Progress, params?: AndroidSocketCloseParams): Promise<AndroidSocketCloseResult>;
}
export type AndroidSocketDataEvent = {
  data: types.Binary,
};
export type AndroidSocketCloseEvent = {};
export type AndroidSocketWriteParams = {
  data: types.Binary,
};
export type AndroidSocketWriteOptions = {

};
export type AndroidSocketWriteResult = void;
export type AndroidSocketCloseParams = {};
export type AndroidSocketCloseOptions = {};
export type AndroidSocketCloseResult = void;

// ----------- AndroidDevice -----------
export type AndroidDeviceInitializer = {
  model: string,
  serial: string,
};
export interface AndroidDeviceChannel extends Channel {
  wait(progress: Progress, params: AndroidDeviceWaitParams): Promise<AndroidDeviceWaitResult>;
  fill(progress: Progress, params: AndroidDeviceFillParams): Promise<AndroidDeviceFillResult>;
  tap(progress: Progress, params: AndroidDeviceTapParams): Promise<AndroidDeviceTapResult>;
  drag(progress: Progress, params: AndroidDeviceDragParams): Promise<AndroidDeviceDragResult>;
  fling(progress: Progress, params: AndroidDeviceFlingParams): Promise<AndroidDeviceFlingResult>;
  longTap(progress: Progress, params: AndroidDeviceLongTapParams): Promise<AndroidDeviceLongTapResult>;
  pinchClose(progress: Progress, params: AndroidDevicePinchCloseParams): Promise<AndroidDevicePinchCloseResult>;
  pinchOpen(progress: Progress, params: AndroidDevicePinchOpenParams): Promise<AndroidDevicePinchOpenResult>;
  scroll(progress: Progress, params: AndroidDeviceScrollParams): Promise<AndroidDeviceScrollResult>;
  swipe(progress: Progress, params: AndroidDeviceSwipeParams): Promise<AndroidDeviceSwipeResult>;
  info(progress: Progress, params: AndroidDeviceInfoParams): Promise<AndroidDeviceInfoResult>;
  screenshot(progress: Progress, params?: AndroidDeviceScreenshotParams): Promise<AndroidDeviceScreenshotResult>;
  inputType(progress: Progress, params: AndroidDeviceInputTypeParams): Promise<AndroidDeviceInputTypeResult>;
  inputPress(progress: Progress, params: AndroidDeviceInputPressParams): Promise<AndroidDeviceInputPressResult>;
  inputTap(progress: Progress, params: AndroidDeviceInputTapParams): Promise<AndroidDeviceInputTapResult>;
  inputSwipe(progress: Progress, params: AndroidDeviceInputSwipeParams): Promise<AndroidDeviceInputSwipeResult>;
  inputDrag(progress: Progress, params: AndroidDeviceInputDragParams): Promise<AndroidDeviceInputDragResult>;
  launchBrowser(progress: Progress, params: AndroidDeviceLaunchBrowserParams): Promise<AndroidDeviceLaunchBrowserResult>;
  open(progress: Progress, params: AndroidDeviceOpenParams): Promise<AndroidDeviceOpenResult>;
  shell(progress: Progress, params: AndroidDeviceShellParams): Promise<AndroidDeviceShellResult>;
  installApk(progress: Progress, params: AndroidDeviceInstallApkParams): Promise<AndroidDeviceInstallApkResult>;
  push(progress: Progress, params: AndroidDevicePushParams): Promise<AndroidDevicePushResult>;
  setDefaultTimeoutNoReply(progress: Progress, params: AndroidDeviceSetDefaultTimeoutNoReplyParams): Promise<AndroidDeviceSetDefaultTimeoutNoReplyResult>;
  connectToWebView(progress: Progress, params: AndroidDeviceConnectToWebViewParams): Promise<AndroidDeviceConnectToWebViewResult>;
  close(progress: Progress, params?: AndroidDeviceCloseParams): Promise<AndroidDeviceCloseResult>;
}
export type AndroidDeviceWebViewAddedEvent = {
  webView: types.AndroidWebView,
};
export type AndroidDeviceWebViewRemovedEvent = {
  pid: number,
};
export type AndroidDeviceWaitParams = {
  selector: types.AndroidSelector,
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitOptions = {
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitResult = void;
export type AndroidDeviceFillParams = {
  selector: types.AndroidSelector,
  text: string,
  timeout?: number,
};
export type AndroidDeviceFillOptions = {
  timeout?: number,
};
export type AndroidDeviceFillResult = void;
export type AndroidDeviceTapParams = {
  selector: types.AndroidSelector,
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapOptions = {
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapResult = void;
export type AndroidDeviceDragParams = {
  selector: types.AndroidSelector,
  dest: types.Point,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragResult = void;
export type AndroidDeviceFlingParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingResult = void;
export type AndroidDeviceLongTapParams = {
  selector: types.AndroidSelector,
  timeout?: number,
};
export type AndroidDeviceLongTapOptions = {
  timeout?: number,
};
export type AndroidDeviceLongTapResult = void;
export type AndroidDevicePinchCloseParams = {
  selector: types.AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseResult = void;
export type AndroidDevicePinchOpenParams = {
  selector: types.AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenResult = void;
export type AndroidDeviceScrollParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollResult = void;
export type AndroidDeviceSwipeParams = {
  selector: types.AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeResult = void;
export type AndroidDeviceInfoParams = {
  selector: types.AndroidSelector,
};
export type AndroidDeviceInfoOptions = {

};
export type AndroidDeviceInfoResult = {
  info: types.AndroidElementInfo,
};
export type AndroidDeviceScreenshotParams = {};
export type AndroidDeviceScreenshotOptions = {};
export type AndroidDeviceScreenshotResult = {
  binary: types.Binary,
};
export type AndroidDeviceInputTypeParams = {
  text: string,
};
export type AndroidDeviceInputTypeOptions = {

};
export type AndroidDeviceInputTypeResult = void;
export type AndroidDeviceInputPressParams = {
  key: string,
};
export type AndroidDeviceInputPressOptions = {

};
export type AndroidDeviceInputPressResult = void;
export type AndroidDeviceInputTapParams = {
  point: types.Point,
};
export type AndroidDeviceInputTapOptions = {

};
export type AndroidDeviceInputTapResult = void;
export type AndroidDeviceInputSwipeParams = {
  segments: types.Point[],
  steps: number,
};
export type AndroidDeviceInputSwipeOptions = {

};
export type AndroidDeviceInputSwipeResult = void;
export type AndroidDeviceInputDragParams = {
  from: types.Point,
  to: types.Point,
  steps: number,
};
export type AndroidDeviceInputDragOptions = {

};
export type AndroidDeviceInputDragResult = void;
export type AndroidDeviceLaunchBrowserParams = {
  sdkLanguage: string,
  pkg?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserOptions = {
  pkg?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: types.NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceDir?: string,
  _debugName?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceOpenParams = {
  command: string,
};
export type AndroidDeviceOpenOptions = {

};
export type AndroidDeviceOpenResult = {
  socket: AndroidSocketChannel,
};
export type AndroidDeviceShellParams = {
  command: string,
};
export type AndroidDeviceShellOptions = {

};
export type AndroidDeviceShellResult = {
  result: types.Binary,
};
export type AndroidDeviceInstallApkParams = {
  file: types.Binary,
  args?: string[],
};
export type AndroidDeviceInstallApkOptions = {
  args?: string[],
};
export type AndroidDeviceInstallApkResult = void;
export type AndroidDevicePushParams = {
  file: types.Binary,
  path: string,
  mode?: number,
};
export type AndroidDevicePushOptions = {
  mode?: number,
};
export type AndroidDevicePushResult = void;
export type AndroidDeviceSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidDeviceSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidDeviceSetDefaultTimeoutNoReplyResult = void;
export type AndroidDeviceConnectToWebViewParams = {
  sdkLanguage: string,
  pid: number,
};
export type AndroidDeviceConnectToWebViewOptions = {

};
export type AndroidDeviceConnectToWebViewResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceCloseParams = {};
export type AndroidDeviceCloseOptions = {};
export type AndroidDeviceCloseResult = void;
